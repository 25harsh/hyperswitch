acknowledgements:
  enabled: true

api:
  enabled: true
  address: 0.0.0.0:8686

sources:
  demo_logs:
    type: demo_logs
    interval: 1
    format: json

  kafka_payments:
    type: kafka
    bootstrap_servers: kafka0:29092
    group_id: sessionizer
    topics:
      - ^hyperswitch-.+
    decoding:
      codec: json

  kafka_intents_source:
    type: kafka
    bootstrap_servers: kafka0:29092
    group_id: sessionizer
    topics:
      - consolidated-intent-events
    decoding:
      codec: json

transforms:
  buffer_with_reduce:
    type: reduce
    inputs:
      - kafka_payments
    group_by:
      - log.log_type
      - log.merchant_id
      - log.payment_id
      - log.attempt_id
      - log.refund_id
      - log.dispute_id
    merge_strategies:
      log: retain
    expire_after_ms: 5000

  init_sessionizer_vars:
    type: remap
    inputs:
      - kafka_payments
    source: >-
      .sessionizer = {
        "table": "payments",
        "id": string!(.log.merchant_id) + "_" + string!(.log.payment_id),
        "id_type": "merchant_payment"
      }

  cassandra_get_old_event:
    type: lua
    inputs:
      - init_sessionizer_vars
    version: "2"
    hooks:
      init: init
      process: process
      shutdown: shutdown
    source: |-
      local socket = require 'socket'

      function sleep(sec)
        socket.select(nil, nil, sec)
      end


      function init(emit)
        local cassandra = require "cassandra"
        
        client = assert(cassandra.new {
          host = "cassandra0",
          port = 9042,
          keyspace = "sessionizer"
        })

        client:settimeout(1000)
        assert(client:connect())
      end

      function db_get(table, id, id_type, version)
        local version = version or 1
        local rows = assert(client:execute(string.format("SELECT * FROM %s WHERE id = ? and id_type = ?", table), {
          id,
          id_type
        }))
        return rows
      end

      function db_get_wait(table, id, id_type, version)
        local is_success, data = pcall(db_get, table, id, id_type, version)

        while not is_success do
          sleep(5)
          client:connect()
          is_success, data = pcall(db_get, table, id, id_type, version)
        end

        return data
      end

      function process(event, emit)
        local sessionizer = event.log.sessionizer
        local data = db_get_wait(sessionizer.table, sessionizer.id, sessionizer.id_type)

        event.log.old_log_type = "intent"
        if #data == 1 then
          event.log.old_log = data[1].state
        end

        emit(event)
      end

      function shutdown(emit)
        client:close()
      end

  club_with_old_event:
    type: remap
    inputs:
      - cassandra_get_old_event
    source: >-
      db_log = .old_log;
      new_log_type = .log_type;
      new_log = .log;

      traverse_map = if new_log_type == "intent" {
        {}
      } else if new_log_type == "attempt" {
        {"attempts": new_log.attempt_id}
      } else if new_log_type == "refund" {
        {"attempts": new_log.attempt_id, "refunds": new_log.refund_id}
      } else if new_log_type == "dispute" {
        {"attempts": new_log.attempt_id, "disputes": new_log.dispute_id}
      } else {
        null
      }

      .sessionizer.db_event = "{}";
      if is_object(traverse_map) {
        traverse_map = object!(traverse_map);
        path = [];
        for_each(traverse_map) -> |k, v| {
          path = append(path, [k, v])
        }
        db_log = parse_json(db_log) ?? {};
        log = get(db_log, path) ?? {};

        new_log = object(new_log) ?? {};
        for_each(new_log) -> |k, v| {
          log = set!(log, [k], v)
        };

        .log = set!(db_log, path, log)
        .sessionizer.db_event = encode_json(.log)
      }

  cassandra_set_new_event:
    type: lua
    inputs:
      - club_with_old_event
    version: "2"
    hooks:
      init: init
      process: process
      shutdown: shutdown
    source: |-
      local socket = require 'socket'

      function sleep(sec)
        socket.select(nil, nil, sec)
      end


      function init(emit)

        local cassandra = require "cassandra"
        
        client = assert(cassandra.new {
          host = "cassandra0",
          port = 9042,
          keyspace = "sessionizer"
        })

        client:settimeout(1000)
        assert(client:connect())

      end

      function db_set(table, state, id, id_type, version)
        version = version or 1
        local res = assert(client:execute(string.format("INSERT INTO %s (id, id_type, state, version) VALUES (?, ?, ?, ?)", table), {
          id,
          id_type,
          state,
          version
        }))
        return res
      end

      function db_set_wait(table, state, id, id_type, version)
        local is_success, res = pcall(db_set, table, state, id, id_type, version)

        while not is_success do
          sleep(5)
          client:connect()
          is_success, res = pcall(db_set, table, state, id, id_type, version)
        end

        return res
      end

      function process(event, emit)
        local sessionizer = event.log.sessionizer
        local new_event_insert = db_set_wait(sessionizer.table, sessionizer.db_event, sessionizer.id, sessionizer.id_type)
        emit(event)
      end

      function shutdown(emit)
        client:close()
      end

  generate_signed_events:
    type: remap
    inputs:
      - cassandra_set_new_event
    source: >-
      events = [];
      if exists(.old_log) {
        .old_log = parse_json!(.old_log);
        .old_log.sign_flag = -1;
        events = push(events, .old_log);
      };
      .log.sign_flag = 1;
      events = push(events, .log);
      . = events

  consolidate_events_intents:
    type: remap
    inputs:
      - generate_signed_events
    source: >-
      del(.attempts)
      # .log_type = "intent";

  consolidate_events_attempts:
    type: remap
    inputs:
      - generate_signed_events
    source: >-
      . = if exists(.attempts) {
        map_values(values(object!(.attempts))) -> |a| {
          attempt = object!(a);
          del(attempt.refunds);
          del(attempt.disputes);
          attempt.sign_flag = .sign_flag;
          # attempt.log_type = "attempt";
          attempt
        }
      } else {
        []
      }

  consolidate_events_refunds:
    type: remap
    inputs:
      - generate_signed_events
    source: >-
      . = if exists(.attempts) {
        flatten(map_values(values(object!(.attempts))) -> |a| {
          attempt = object!(a);
          if exists(attempt.refunds) {
            map_values(values(object!(attempt.refunds))) -> |r| {
              refund = object!(r);
              refund.sign_flag = .sign_flag;
              # refund.log_type = "refund";
              refund
            }
          } else {
            []
          }
        })
      } else {
        []
      }

  consolidate_events_disputes:
    type: remap
    inputs:
      - generate_signed_events
    source: >-
      . = if exists(.attempts) {
        flatten(map_values(values(object!(.attempts))) -> |a| {
          attempt = object!(a);
          if exists(attempt.disputes) {
            map_values(values(object!(attempt.disputes))) -> |d| {
              dispute = object!(d);
              dispute.sign_flag = .sign_flag;
              # dispute.log_type = "dispute";
              dispute
            }
          } else {
            []
          }
        })
      } else {
        []
      }

sinks:
  kafka_intents_sink:
    type: kafka
    inputs:
      - consolidate_events_intents
    bootstrap_servers: kafka0:29092
    topic: consolidated-intent-events
    encoding:
      codec: json

  console_intents:
    inputs:
      - kafka_intents_source
    target: stdout
    type: console
    encoding:
      codec: json

  console_attempts:
    inputs:
      - consolidate_events_attempts
    target: stdout
    type: console
    encoding:
      codec: json

  console_refunds:
    inputs:
      - consolidate_events_refunds
    target: stdout
    type: console
    encoding:
      codec: json

  console_disputes:
    inputs:
      - consolidate_events_disputes
    target: stdout
    type: console
    encoding:
      codec: json
