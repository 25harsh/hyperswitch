api:
  enabled: true
  address: 0.0.0.0:8686
sources:
  demo_logs:
    type: demo_logs
    interval: 1
    format: json
  kafka_payments:
    type: kafka
    bootstrap_servers: kafka0:29092
    group_id: sessionizer
    topics:
      - ^hyperswitch-.+
    decoding:
      codec: json

transforms:
  cassandra_get_old_event:
    type: lua
    inputs:
      - kafka_payments
    version: "2"
    hooks:
      init: init
      process: process
      shutdown: shutdown
    source: |-
      function init(emit)
        local cassandra = require "cassandra"
        
        client = assert(cassandra.new {
          host = "cassandra0",
          port = 9042,
          keyspace = "sessionizer"
        })

        client:settimeout(1000)
        assert(client:connect())
      end

      function db_get(id, id_type, version)
        version = version or 1
        local rows = assert(client:execute("SELECT * FROM payments WHERE id = ? and id_type = ?", {
          id,
          id_type
        }))
        return rows
      end

      function copy(obj, seen)
        if type(obj) ~= 'table' then return obj end
        if seen and seen[obj] then return seen[obj] end
        local s = seen or {}
        local res = setmetatable({}, getmetatable(obj))
        s[obj] = res
        for k, v in pairs(obj) do res[copy(k, s)] = copy(v, s) end
        return res
      end

      function process(event, emit)
        local json = require "json"

        local old_event = db_get(string.format("%s_%s", event.log.log.merchant_id, event.log.log.payment_id), "merchant_payment")
        if #old_event == 1 then
          event.log.old_log = json.decode(old_event[1].state)
        end
        emit(event)
      end

      function shutdown(emit)
        client:close()
      end

      function emit_signed_log(emit, event, log, sign)
        event.log.log = log
        event.log.sign = sign
        emit(event)
      end

  club_with_old_event:
    type: remap
    inputs:
      - cassandra_get_old_event
    source: >-
      db_log = .old_log;
      new_log_type = .log_type;
      new_log = .log;

      traverse_map = if new_log_type == "intent" {
        {}
      } else if new_log_type == "attempt" {
        {"attempts": new_log.attempt_id}
      } else if new_log_type == "refund" {
        {"attempts": new_log.attempt_id, "refunds": new_log.refund_id}
      } else if new_log_type == "dispute" {
        {"attempts": new_log.attempt_id, "disputes": new_log.dispute_id}
      } else {
        null
      }

      if is_object(traverse_map) {
        traverse_map = object!(traverse_map);
        path = [];
        for_each(traverse_map) -> |k, v| {
          path = append(path, [k, v])
        }
        log = get(db_log, path) ?? {};

        new_log = object(new_log) ?? {};
        for_each(new_log) -> |k, v| {
          log = set!(log, [k], v)
        };

        .db_merchant_id = log.merchant_id
        .db_payment_id = log.payment_id
        .log = set!(db_log, path, log)
      }

  cassandra_set_new_event:
    type: lua
    inputs:
      - club_with_old_event
    version: "2"
    hooks:
      init: init
      process: process
      shutdown: shutdown
    source: |-
      function init(emit)

        local cassandra = require "cassandra"
        
        client = assert(cassandra.new {
          host = "cassandra0",
          port = 9042,
          keyspace = "sessionizer"
        })

        client:settimeout(1000)
        assert(client:connect())

      end

      function db_set(state, id, id_type, version)
        version = version or 1
        local res = assert(client:execute("INSERT INTO payments (id, id_type, state, version) VALUES (?, ?, ?, ?)", {
          id,
          id_type,
          state,
          version
        }))
        return res
      end

      function process(event, emit)
        local json = require "json"
        local new_event_insert = db_set(json.encode(event.log.log), string.format("%s_%s", event.log.db_merchant_id, event.log.db_payment_id), "merchant_payment")
        emit(event)
      end

      function shutdown(emit)
        client:close()
      end

  generate_signed_events:
    type: remap
    inputs:
      - cassandra_set_new_event
    source: >-
      events = [];
      if exists(.old_log) {
        .old_log.sign_flag = -1;
        events = push(events, .old_log);
      };
      .log.sign_flag = 1;
      events = push(events, .log);
      . = events

  # split_events:
  #   type: remap
  #   inputs:
  #     - generate_signed_events
  #   source: >-

sinks:
  console:
    inputs:
      - generate_signed_events
    target: stdout
    type: console
    encoding:
      codec: json

  # type Metric =
  #   | TotalCount
  #   | CountMatchString { key: string, value: string, alias: string }
  #   | TotalAmount { amount_key: string }
  #   | TotalAmountMatchString { amount_key: string, key: string, value: string, alias: string };

  # metrics = [CountTotal, CountMatchString {"status", "charged"}, TotalAmount {"amount"}, TotalAmountMatchString {"amount", "status", "charged"}];

  # fn metric_name(metric) {
  #     match metric {
  #       TotalCount => "count"
  #       CountMatchString { key: key, value: value, alias: alias } => alias
  #       TotalAmount => amount
  #       TotalAmountMatchString { amount_key: amount_key, key: key, value: value, alias: alias } => alias
  #     }
  # }
