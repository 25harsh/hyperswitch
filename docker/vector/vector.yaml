acknowledgements:
  enabled: true

api:
  enabled: true
  address: 0.0.0.0:8686

sources:
  kafka_payments:
    type: kafka
    bootstrap_servers: kafka0:29092
    group_id: sessionizer
    topics:
      - hyperswitch-consolidated-events
    decoding:
      codec: json

transforms:
  init_sessionizer_vars:
    type: remap
    inputs:
      - kafka_payments
    drop_on_error: true
    reroute_dropped: true
    source: >-
      .sessionizer = {
        "table": "${CASSANDRA_TABLE:-payments}",
        "id": string!(.log.merchant_id) + "_" + string!(.log.payment_id),
        "db_log_type": "payment_intent"
      };
      log({"log": ., "type": "individual"}, rate_limit_secs:0);

  buffer_each_log_type:
    type: reduce
    inputs:
      - init_sessionizer_vars
    group_by:
      - log.log_type
      - log.merchant_id
      - log.payment_id
      - log.attempt_id
      - log.refund_id
      - log.dispute_id
    merge_strategies:
      log: retain
    expire_after_ms: 3000

  concat_all_log_types:
    type: reduce
    inputs:
      - buffer_each_log_type
    group_by:
      - log.merchant_id
      - log.payment_id
    merge_strategies:
      log: array
      log_type: array
    expire_after_ms: 5000

  debug_log:
    type: remap
    drop_on_error: true
    reroute_dropped: true
    inputs:
      - concat_all_log_types
    source: >-
      log({"log": ., "type": "combined"}, rate_limit_secs:0);

  cassandra_sessionize:
    type: lua
    inputs:
      - debug_log
    version: "2"
    hooks:
      init: init
      process: process
      shutdown: shutdown
    source: |-
      local socket = require "socket"
      local cassandra = require "cassandra"
      local json = require "json"

      function sleep(sec)
        socket.select(nil, nil, sec)
      end

      function client_connect()
        assert(client:connect())
      end

      function client_close()
        assert(client:close())
      end

      function create_cassandra_connection()
        client = assert(cassandra.new {
          host = os.getenv("CASSANDRA_HOST") or "cassandra0",
          port = os.getenv("CASSANDRA_PORT") or 9042,
          keyspace = os.getenv("CASSANDRA_KEYSPACE") or "sessionizer",
          auth = cassandra.auth_providers.plain_text(os.getenv("CASSANDRA_USERNAME") or "cassandra", os.getenv("CASSANDRA_PASSWORD") or "cassandra"),
          ssl = os.getenv("CASSANDRA_SSL") or false,
          cert = os.getenv("CASSANDRA_CERT") or ""
        })

        client:settimeout(1000)
        client:setkeepalive(0)
        client_connect()
      end

      function db_get(table, id, version)
        local version = version or 1
        local rows = assert(client:execute(string.format("SELECT * FROM %s WHERE id = ?", table), {
          id
        }))
        return rows
      end

      function db_set(table, state, id, version)
        version = version or 1
        local res = assert(client:execute(string.format("INSERT INTO %s (id, state, version) VALUES (?, ?, ?)", table), {
          id,
          state,
          version
        },{consistency = cassandra.consistencies.local_quorum}))
        return res
      end

      function db_get_wait(table, id, version)
        local is_success, data = pcall(db_get, table, id, version)
        while not is_success do
          sleep(1)

          print(string.format("db_get - recreate cassandra connection start - reason - %s", data))
          local connection_closed, err = pcall(client_close)
          print(string.format("db_get - close old cassandra connection - result - %s, %s", connection_closed, err))
          local connection_success, err = pcall(create_cassandra_connection)
          print(string.format("db_get - recreate cassandra connection end - result - %s, %s", connection_success, err))

          is_success, data = pcall(db_get, table, id, version)
        end

        return data
      end

      function db_set_wait(table, state, id, version)
        local is_success, res = pcall(db_set, table, state, id, version)

        while not is_success do
          sleep(1)

          print(string.format("db_set - recreate cassandra connection start - reason - %s", res))
          local connection_closed, err = pcall(client_close)
          print(string.format("db_set - close old cassandra connection - result - %s, %s", connection_closed, err))
          local connection_success, err = pcall(create_cassandra_connection)
          print(string.format("db_set - recreate cassandra connection end - result - %s, %s", connection_success, err))

          is_success, res = pcall(db_set, table, state, id, version)
        end

        return res
      end

      function get_value(tb, path)
        local value = tb

        for i, v in ipairs(path) do
          value = value[v] or {}
        end

        return value
      end

      function set_value(tb, path, value, index)
        local index = index or 1

        if index > #path then
          return value
        else
          tb[path[index]] = set_value(tb[path[index]] or {}, path, value, index + 1)
        end
        
        return tb
      end

      function merge_log(db_log, new_log, traverse_map)
        local log = get_value(db_log, traverse_map)

        for k, v in pairs(new_log) do
          log[k] = v
        end

        return set_value(db_log, traverse_map, log)
      end

      function init(emit) 
        create_cassandra_connection()  
      end

      function process(event, emit)
        local start_time = os.clock()
        local sessionizer = event.log.sessionizer
        local new_log_types = event.log.log_type
        local new_logs = event.log.log
        local db_log = {}

        local data = db_get_wait(sessionizer.table, sessionizer.id)

        if #data == 1 then
          event.log.old_log = data[1].state
          db_log = json.decode(data[1].state)
        end
        

        for i, new_log in ipairs(new_logs) do
          new_log_type = new_log_types[i];

          local traverse_map = nil
          if new_log_type == "payment_intent" then
            traverse_map = {}
          elseif new_log_type == "payment_attempt" then
            traverse_map = {"attempts", new_log.attempt_id}
          elseif new_log_type == "refund" then
            traverse_map = {"attempts", new_log.attempt_id, "refunds", new_log.refund_id}
          elseif new_log_type == "dispute" then
            traverse_map = {"attempts", new_log.attempt_id, "disputes", new_log.dispute_id}
          end

          db_log = merge_log(db_log, new_log, traverse_map);
        end

        event.log.log = db_log

        local _new_event_insert = db_set_wait(sessionizer.table, json.encode(db_log), sessionizer.id)
        emit(event)

        print(string.format("lua execution time: %.3f", os.clock() - start_time))
      end

      function shutdown(emit)
        client:close()
      end

  generate_signed_events:
    type: remap
    inputs:
      - cassandra_sessionize
    drop_on_error: true
    reroute_dropped: true
    source: >-
      events = [];
      if exists(.old_log) {
        .old_log = parse_json(.old_log) ?? {};
        .old_log.sign_flag = -1;
        events = push(events, .old_log);
      };
      .log.sign_flag = 1;
      events = push(events, .log);
      . = events

  consolidate_events:
    type: remap
    inputs:
      - generate_signed_events
    drop_on_error: true
    reroute_dropped: true
    source: >-
      roll_up = {};
      pass_down = {};
      payment_intent_log = .;
      pass_down_payment_intent = {};
      pass_down = merge(pass_down, pass_down_payment_intent);
      roll_up_payment_attempt = {"payment_attempt_success_amount":0, "payment_attempt_success_count":0, "payment_attempt_total_amount":0, "payment_attempt_total_count":0, };
      roll_up = merge(roll_up, roll_up_payment_attempt);

      attempts = object(payment_intent_log.attempts) ?? {};
      for_each(attempts) -> |attempt_id, payment_attempt| {
          payment_attempt_log = object(payment_attempt) ?? {};
          payment_attempt_log = merge(payment_attempt_log, pass_down);

          roll_up.payment_attempt_success_amount = roll_up.payment_attempt_success_amount + to_int(payment_attempt_log.amount) ?? 0;
      roll_up.payment_attempt_success_count = roll_up.payment_attempt_success_count + 1;
      roll_up.payment_attempt_total_amount = roll_up.payment_attempt_total_amount + to_int(payment_attempt_log.amount) ?? 0;
      roll_up.payment_attempt_total_count = roll_up.payment_attempt_total_count + 1;

          pass_down_payment_attempt = {"payment_attempt_connector":payment_attempt_log.connector, };
      pass_down = merge(pass_down, pass_down_payment_attempt);
      roll_up_refund = {"refund_success_amount":0, "refund_success_count":0, "refund_total_amount":0, "refund_total_count":0, };
      roll_up = merge(roll_up, roll_up_refund);

      refunds = object(payment_attempt_log.refunds) ?? {};
      for_each(refunds) -> |refund_id, refund| {
          refund_log = object(refund) ?? {};
          refund_log = merge(refund_log, pass_down);

          roll_up.refund_success_amount = roll_up.refund_success_amount + to_int(refund_log.refund_amount) ?? 0;
      roll_up.refund_success_count = roll_up.refund_success_count + 1;
      roll_up.refund_total_amount = roll_up.refund_total_amount + to_int(refund_log.refund_amount) ?? 0;
      roll_up.refund_total_count = roll_up.refund_total_count + 1;

          
          payment_attempt_log.refunds = set!(payment_attempt_log.refunds, [refund_id], refund_log);
      };
      roll_up_dispute = {"dispute_success_amount":0, "dispute_success_count":0, "dispute_total_amount":0, "dispute_total_count":0, };
      roll_up = merge(roll_up, roll_up_dispute);

      disputes = object(payment_attempt_log.disputes) ?? {};
      for_each(disputes) -> |dispute_id, dispute| {
          dispute_log = object(dispute) ?? {};
          dispute_log = merge(dispute_log, pass_down);

          roll_up.dispute_success_amount = roll_up.dispute_success_amount + to_int(dispute_log.dispute_amount) ?? 0;
      roll_up.dispute_success_count = roll_up.dispute_success_count + 1;
      roll_up.dispute_total_amount = roll_up.dispute_total_amount + to_int(dispute_log.dispute_amount) ?? 0;
      roll_up.dispute_total_count = roll_up.dispute_total_count + 1;

          
          payment_attempt_log.disputes = set!(payment_attempt_log.disputes, [dispute_id], dispute_log);
      };
      payment_attempt_log = merge(payment_attempt_log, roll_up);


          payment_intent_log.attempts = set!(payment_intent_log.attempts, [attempt_id], payment_attempt_log);
      };
      payment_intent_log = merge(payment_intent_log, roll_up);

      . = payment_intent_log;

  consolidate_events_intents:
    type: remap
    inputs:
      - consolidate_events
    drop_on_error: true
    reroute_dropped: true
    source: >-
      if exists(.merchant_id) && exists(.payment_id) {
        del(.attempts);
        .sessionizer_key = string!(.merchant_id) + "_" + string!(.payment_id);
        # .log_type = "payment_intent";
      } else {
        . = []
      }

  consolidate_events_attempts:
    type: remap
    inputs:
      - consolidate_events
    drop_on_error: true
    reroute_dropped: true
    source: >-
      . = flatten(map_values(values(object(.attempts) ?? {})) -> |a| {
        attempt = object(a) ?? {};
        if exists(attempt.merchant_id) && exists(attempt.payment_id) && exists(attempt.attempt_id) {
          del(attempt.refunds);
          del(attempt.disputes);
          attempt.sign_flag = .sign_flag;
          # attempt.log_type = "payment_attempt";
          attempt.sessionizer_key = string!(attempt.merchant_id) + "_" + string!(attempt.payment_id) + "_" + string!(attempt.attempt_id);
          attempt
        } else {
          []
        }
      })

  consolidate_events_refunds:
    type: remap
    inputs:
      - consolidate_events
    drop_on_error: true
    reroute_dropped: true
    source: >-
      . = flatten(map_values(values(object(.attempts) ?? {})) -> |a| {
          attempt = object(a) ?? {};
          map_values(values(object(attempt.refunds) ?? {})) -> |r| {
            refund = object(r) ?? {};
            if exists(refund.merchant_id) && exists(refund.payment_id) && exists(refund.attempt_id) && exists(refund.refund_id) {
              refund.sign_flag = .sign_flag;
              # refund.log_type = "refund";
              refund.sessionizer_key = string!(refund.merchant_id) + "_" + string!(refund.payment_id) + "_" + string!(refund.attempt_id) + "_" + string!(refund.refund_id);
              refund
            } else {
              []
            }
          }
        })

  consolidate_events_disputes:
    type: remap
    inputs:
      - consolidate_events
    drop_on_error: true
    reroute_dropped: true
    source: >-
      . = flatten(map_values(values(object(.attempts) ?? {})) -> |a| {
          attempt = object(a) ?? {};
          map_values(values(object(attempt.disputes) ?? {})) -> |d| {
            dispute = object(d) ?? {};
            if exists(dispute.merchant_id) && exists(dispute.payment_id) && exists(dispute.attempt_id) && exists(dispute.dispute_id) {
              dispute.sign_flag = .sign_flag;
              # dispute.log_type = "dispute";
              dispute.sessionizer_key = string!(dispute.merchant_id) + "_" + string!(dispute.payment_id) + "_" + string!(dispute.attempt_id) + "_" + string!(dispute.dispute_id);
              dispute
            } else {
              []
            }
          }
        })

sinks:
  # kafka_intents_sink:
  #   type: kafka
  #   inputs:
  #     - consolidate_events_intents
  #   bootstrap_servers: kafka0:29092
  #   topic: consolidated-intent-events
  #   key_field: sessionizer_key
  #   encoding:
  #     codec: json

  console_intents:
    inputs:
      - consolidate_events_intents
    target: stdout
    type: console
    encoding:
      codec: json

  console_attempts:
    inputs:
      - consolidate_events_attempts
    target: stdout
    type: console
    encoding:
      codec: json

  console_refunds:
    inputs:
      - consolidate_events_refunds
    target: stdout
    type: console
    encoding:
      codec: json

  console_disputes:
    inputs:
      - consolidate_events_disputes
    target: stdout
    type: console
    encoding:
      codec: json

  console_dropped:
    inputs:
      - consolidate_events.dropped
      - consolidate_events_attempts.dropped
      - consolidate_events_disputes.dropped
      - consolidate_events_intents.dropped
      - consolidate_events_refunds.dropped
      - debug_log.dropped
      - generate_signed_events.dropped
      - init_sessionizer_vars.dropped
    target: stdout
    type: console
    encoding:
      codec: json
