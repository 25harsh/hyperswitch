from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, TypeVar, Union, cast

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.address_details import AddressDetails
    from ..models.customer_update_request_metadata_type_0 import CustomerUpdateRequestMetadataType0


T = TypeVar("T", bound="CustomerUpdateRequest")


@_attrs_define
class CustomerUpdateRequest:
    """The identifier for the customer object. If not provided the customer ID will be autogenerated.

    Attributes:
        name (Union[None, Unset, str]): The customer's name Example: Jon Test.
        email (Union[None, Unset, str]): The customer's email address Example: JonTest@test.com.
        phone (Union[None, Unset, str]): The customer's phone number Example: 9123456789.
        description (Union[None, Unset, str]): An arbitrary string that you can attach to a customer object. Example:
            First Customer.
        phone_country_code (Union[None, Unset, str]): The country code for the customer phone number Example: +65.
        address (Union['AddressDetails', None, Unset]):
        metadata (Union['CustomerUpdateRequestMetadataType0', None, Unset]): You can specify up to 50 keys, with key
            names up to 40 characters long and values up to 500
            characters long. Metadata is useful for storing additional, structured information on an
            object.
    """

    name: Union[None, Unset, str] = UNSET
    email: Union[None, Unset, str] = UNSET
    phone: Union[None, Unset, str] = UNSET
    description: Union[None, Unset, str] = UNSET
    phone_country_code: Union[None, Unset, str] = UNSET
    address: Union["AddressDetails", None, Unset] = UNSET
    metadata: Union["CustomerUpdateRequestMetadataType0", None, Unset] = UNSET
    additional_properties: dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> dict[str, Any]:
        from ..models.address_details import AddressDetails
        from ..models.customer_update_request_metadata_type_0 import CustomerUpdateRequestMetadataType0

        name: Union[None, Unset, str]
        if isinstance(self.name, Unset):
            name = UNSET
        else:
            name = self.name

        email: Union[None, Unset, str]
        if isinstance(self.email, Unset):
            email = UNSET
        else:
            email = self.email

        phone: Union[None, Unset, str]
        if isinstance(self.phone, Unset):
            phone = UNSET
        else:
            phone = self.phone

        description: Union[None, Unset, str]
        if isinstance(self.description, Unset):
            description = UNSET
        else:
            description = self.description

        phone_country_code: Union[None, Unset, str]
        if isinstance(self.phone_country_code, Unset):
            phone_country_code = UNSET
        else:
            phone_country_code = self.phone_country_code

        address: Union[None, Unset, dict[str, Any]]
        if isinstance(self.address, Unset):
            address = UNSET
        elif isinstance(self.address, AddressDetails):
            address = self.address.to_dict()
        else:
            address = self.address

        metadata: Union[None, Unset, dict[str, Any]]
        if isinstance(self.metadata, Unset):
            metadata = UNSET
        elif isinstance(self.metadata, CustomerUpdateRequestMetadataType0):
            metadata = self.metadata.to_dict()
        else:
            metadata = self.metadata

        field_dict: dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if name is not UNSET:
            field_dict["name"] = name
        if email is not UNSET:
            field_dict["email"] = email
        if phone is not UNSET:
            field_dict["phone"] = phone
        if description is not UNSET:
            field_dict["description"] = description
        if phone_country_code is not UNSET:
            field_dict["phone_country_code"] = phone_country_code
        if address is not UNSET:
            field_dict["address"] = address
        if metadata is not UNSET:
            field_dict["metadata"] = metadata

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        from ..models.address_details import AddressDetails
        from ..models.customer_update_request_metadata_type_0 import CustomerUpdateRequestMetadataType0

        d = dict(src_dict)

        def _parse_name(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        name = _parse_name(d.pop("name", UNSET))

        def _parse_email(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        email = _parse_email(d.pop("email", UNSET))

        def _parse_phone(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        phone = _parse_phone(d.pop("phone", UNSET))

        def _parse_description(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        description = _parse_description(d.pop("description", UNSET))

        def _parse_phone_country_code(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        phone_country_code = _parse_phone_country_code(d.pop("phone_country_code", UNSET))

        def _parse_address(data: object) -> Union["AddressDetails", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                address_type_1 = AddressDetails.from_dict(data)

                return address_type_1
            except:  # noqa: E722
                pass
            return cast(Union["AddressDetails", None, Unset], data)

        address = _parse_address(d.pop("address", UNSET))

        def _parse_metadata(data: object) -> Union["CustomerUpdateRequestMetadataType0", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                metadata_type_0 = CustomerUpdateRequestMetadataType0.from_dict(data)

                return metadata_type_0
            except:  # noqa: E722
                pass
            return cast(Union["CustomerUpdateRequestMetadataType0", None, Unset], data)

        metadata = _parse_metadata(d.pop("metadata", UNSET))

        customer_update_request = cls(
            name=name,
            email=email,
            phone=phone,
            description=description,
            phone_country_code=phone_country_code,
            address=address,
            metadata=metadata,
        )

        customer_update_request.additional_properties = d
        return customer_update_request

    @property
    def additional_keys(self) -> list[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
