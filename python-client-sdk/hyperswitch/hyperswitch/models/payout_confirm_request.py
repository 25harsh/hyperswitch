from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, TypeVar, Union, cast

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..models.country_alpha_2 import CountryAlpha2
from ..models.currency import Currency
from ..models.payout_connectors import PayoutConnectors
from ..models.payout_entity_type import PayoutEntityType
from ..models.payout_send_priority import PayoutSendPriority
from ..models.payout_type import PayoutType
from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.address import Address
    from ..models.customer_details import CustomerDetails
    from ..models.payout_confirm_request_metadata_type_0 import PayoutConfirmRequestMetadataType0
    from ..models.payout_create_payout_link_config import PayoutCreatePayoutLinkConfig
    from ..models.payout_method_data_type_0 import PayoutMethodDataType0
    from ..models.payout_method_data_type_1 import PayoutMethodDataType1
    from ..models.payout_method_data_type_2 import PayoutMethodDataType2
    from ..models.routing_algorithm_type_0 import RoutingAlgorithmType0
    from ..models.routing_algorithm_type_1 import RoutingAlgorithmType1
    from ..models.routing_algorithm_type_2 import RoutingAlgorithmType2
    from ..models.routing_algorithm_type_3 import RoutingAlgorithmType3


T = TypeVar("T", bound="PayoutConfirmRequest")


@_attrs_define
class PayoutConfirmRequest:
    """
    Attributes:
        client_secret (str): It's a token used for client side verification.
        amount (Union[None, Unset, int]): The payout amount. Amount for the payout in lowest denomination of the
            currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc., Example: 1000.
        currency (Union[Currency, None, Unset]):
        routing (Union['RoutingAlgorithmType0', 'RoutingAlgorithmType1', 'RoutingAlgorithmType2',
            'RoutingAlgorithmType3', None, Unset]):
        connector (Union[None, Unset, list[PayoutConnectors]]): This field allows the merchant to manually select a
            connector with which the payout can go through. Example: ['wise', 'adyen'].
        payout_type (Union[None, PayoutType, Unset]):
        payout_method_data (Union['PayoutMethodDataType0', 'PayoutMethodDataType1', 'PayoutMethodDataType2', None,
            Unset]):
        billing (Union['Address', None, Unset]):
        auto_fulfill (Union[None, Unset, bool]): Set to true to confirm the payout without review, no further action
            required Default: False. Example: True.
        customer_id (Union[None, Unset, str]): The identifier for the customer object. If not provided the customer ID
            will be autogenerated. _Deprecated: Use customer_id instead._ Example: cus_y3oqhf46pyzuxjbcn2giaqnb44.
        customer (Union['CustomerDetails', None, Unset]):
        return_url (Union[None, Unset, str]): The URL to redirect after the completion of the operation Example:
            https://hyperswitch.io.
        business_country (Union[CountryAlpha2, None, Unset]):
        business_label (Union[None, Unset, str]): Business label of the merchant for this payout. _Deprecated: Use
            profile_id instead._ Example: food.
        description (Union[None, Unset, str]): A description of the payout Example: It's my first payout request.
        entity_type (Union[None, PayoutEntityType, Unset]):
        recurring (Union[None, Unset, bool]): Specifies whether or not the payout request is recurring Default: False.
        metadata (Union['PayoutConfirmRequestMetadataType0', None, Unset]): You can specify up to 50 keys, with key
            names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional,
            structured information on an object.
        payout_token (Union[None, Unset, str]): Provide a reference to a stored payout method, used to process the
            payout. Example: 187282ab-40ef-47a9-9206-5099ba31e432.
        profile_id (Union[None, Unset, str]): The business profile to use for this payout, especially if there are
            multiple business profiles associated with the account, otherwise default business profile associated with the
            merchant account will be used.
        priority (Union[None, PayoutSendPriority, Unset]):
        payout_link (Union[None, Unset, bool]): Whether to get the payout link (if applicable). Merchant need to specify
            this during the Payout _Create_, this field can not be updated during Payout _Update_. Default: False. Example:
            True.
        payout_link_config (Union['PayoutCreatePayoutLinkConfig', None, Unset]):
        session_expiry (Union[None, Unset, int]): Will be used to expire client secret after certain amount of time to
            be supplied in seconds
            (900) for 15 mins Example: 900.
        email (Union[None, Unset, str]): Customer's email. _Deprecated: Use customer object instead._ Example:
            johntest@test.com.
        name (Union[None, Unset, str]): Customer's name. _Deprecated: Use customer object instead._ Example: John Test.
        phone (Union[None, Unset, str]): Customer's phone. _Deprecated: Use customer object instead._ Example:
            9123456789.
        phone_country_code (Union[None, Unset, str]): Customer's phone country code. _Deprecated: Use customer object
            instead._ Example: +1.
        payout_method_id (Union[None, Unset, str]): Identifier for payout method
    """

    client_secret: str
    amount: Union[None, Unset, int] = UNSET
    currency: Union[Currency, None, Unset] = UNSET
    routing: Union[
        "RoutingAlgorithmType0", "RoutingAlgorithmType1", "RoutingAlgorithmType2", "RoutingAlgorithmType3", None, Unset
    ] = UNSET
    connector: Union[None, Unset, list[PayoutConnectors]] = UNSET
    payout_type: Union[None, PayoutType, Unset] = UNSET
    payout_method_data: Union[
        "PayoutMethodDataType0", "PayoutMethodDataType1", "PayoutMethodDataType2", None, Unset
    ] = UNSET
    billing: Union["Address", None, Unset] = UNSET
    auto_fulfill: Union[None, Unset, bool] = False
    customer_id: Union[None, Unset, str] = UNSET
    customer: Union["CustomerDetails", None, Unset] = UNSET
    return_url: Union[None, Unset, str] = UNSET
    business_country: Union[CountryAlpha2, None, Unset] = UNSET
    business_label: Union[None, Unset, str] = UNSET
    description: Union[None, Unset, str] = UNSET
    entity_type: Union[None, PayoutEntityType, Unset] = UNSET
    recurring: Union[None, Unset, bool] = False
    metadata: Union["PayoutConfirmRequestMetadataType0", None, Unset] = UNSET
    payout_token: Union[None, Unset, str] = UNSET
    profile_id: Union[None, Unset, str] = UNSET
    priority: Union[None, PayoutSendPriority, Unset] = UNSET
    payout_link: Union[None, Unset, bool] = False
    payout_link_config: Union["PayoutCreatePayoutLinkConfig", None, Unset] = UNSET
    session_expiry: Union[None, Unset, int] = UNSET
    email: Union[None, Unset, str] = UNSET
    name: Union[None, Unset, str] = UNSET
    phone: Union[None, Unset, str] = UNSET
    phone_country_code: Union[None, Unset, str] = UNSET
    payout_method_id: Union[None, Unset, str] = UNSET
    additional_properties: dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> dict[str, Any]:
        from ..models.address import Address
        from ..models.customer_details import CustomerDetails
        from ..models.payout_confirm_request_metadata_type_0 import PayoutConfirmRequestMetadataType0
        from ..models.payout_create_payout_link_config import PayoutCreatePayoutLinkConfig
        from ..models.payout_method_data_type_0 import PayoutMethodDataType0
        from ..models.payout_method_data_type_1 import PayoutMethodDataType1
        from ..models.payout_method_data_type_2 import PayoutMethodDataType2
        from ..models.routing_algorithm_type_0 import RoutingAlgorithmType0
        from ..models.routing_algorithm_type_1 import RoutingAlgorithmType1
        from ..models.routing_algorithm_type_2 import RoutingAlgorithmType2
        from ..models.routing_algorithm_type_3 import RoutingAlgorithmType3

        client_secret = self.client_secret

        amount: Union[None, Unset, int]
        if isinstance(self.amount, Unset):
            amount = UNSET
        else:
            amount = self.amount

        currency: Union[None, Unset, str]
        if isinstance(self.currency, Unset):
            currency = UNSET
        elif isinstance(self.currency, Currency):
            currency = self.currency.value
        else:
            currency = self.currency

        routing: Union[None, Unset, dict[str, Any]]
        if isinstance(self.routing, Unset):
            routing = UNSET
        elif isinstance(self.routing, RoutingAlgorithmType0):
            routing = self.routing.to_dict()
        elif isinstance(self.routing, RoutingAlgorithmType1):
            routing = self.routing.to_dict()
        elif isinstance(self.routing, RoutingAlgorithmType2):
            routing = self.routing.to_dict()
        elif isinstance(self.routing, RoutingAlgorithmType3):
            routing = self.routing.to_dict()
        else:
            routing = self.routing

        connector: Union[None, Unset, list[str]]
        if isinstance(self.connector, Unset):
            connector = UNSET
        elif isinstance(self.connector, list):
            connector = []
            for connector_type_0_item_data in self.connector:
                connector_type_0_item = connector_type_0_item_data.value
                connector.append(connector_type_0_item)

        else:
            connector = self.connector

        payout_type: Union[None, Unset, str]
        if isinstance(self.payout_type, Unset):
            payout_type = UNSET
        elif isinstance(self.payout_type, PayoutType):
            payout_type = self.payout_type.value
        else:
            payout_type = self.payout_type

        payout_method_data: Union[None, Unset, dict[str, Any]]
        if isinstance(self.payout_method_data, Unset):
            payout_method_data = UNSET
        elif isinstance(self.payout_method_data, PayoutMethodDataType0):
            payout_method_data = self.payout_method_data.to_dict()
        elif isinstance(self.payout_method_data, PayoutMethodDataType1):
            payout_method_data = self.payout_method_data.to_dict()
        elif isinstance(self.payout_method_data, PayoutMethodDataType2):
            payout_method_data = self.payout_method_data.to_dict()
        else:
            payout_method_data = self.payout_method_data

        billing: Union[None, Unset, dict[str, Any]]
        if isinstance(self.billing, Unset):
            billing = UNSET
        elif isinstance(self.billing, Address):
            billing = self.billing.to_dict()
        else:
            billing = self.billing

        auto_fulfill: Union[None, Unset, bool]
        if isinstance(self.auto_fulfill, Unset):
            auto_fulfill = UNSET
        else:
            auto_fulfill = self.auto_fulfill

        customer_id: Union[None, Unset, str]
        if isinstance(self.customer_id, Unset):
            customer_id = UNSET
        else:
            customer_id = self.customer_id

        customer: Union[None, Unset, dict[str, Any]]
        if isinstance(self.customer, Unset):
            customer = UNSET
        elif isinstance(self.customer, CustomerDetails):
            customer = self.customer.to_dict()
        else:
            customer = self.customer

        return_url: Union[None, Unset, str]
        if isinstance(self.return_url, Unset):
            return_url = UNSET
        else:
            return_url = self.return_url

        business_country: Union[None, Unset, str]
        if isinstance(self.business_country, Unset):
            business_country = UNSET
        elif isinstance(self.business_country, CountryAlpha2):
            business_country = self.business_country.value
        else:
            business_country = self.business_country

        business_label: Union[None, Unset, str]
        if isinstance(self.business_label, Unset):
            business_label = UNSET
        else:
            business_label = self.business_label

        description: Union[None, Unset, str]
        if isinstance(self.description, Unset):
            description = UNSET
        else:
            description = self.description

        entity_type: Union[None, Unset, str]
        if isinstance(self.entity_type, Unset):
            entity_type = UNSET
        elif isinstance(self.entity_type, PayoutEntityType):
            entity_type = self.entity_type.value
        else:
            entity_type = self.entity_type

        recurring: Union[None, Unset, bool]
        if isinstance(self.recurring, Unset):
            recurring = UNSET
        else:
            recurring = self.recurring

        metadata: Union[None, Unset, dict[str, Any]]
        if isinstance(self.metadata, Unset):
            metadata = UNSET
        elif isinstance(self.metadata, PayoutConfirmRequestMetadataType0):
            metadata = self.metadata.to_dict()
        else:
            metadata = self.metadata

        payout_token: Union[None, Unset, str]
        if isinstance(self.payout_token, Unset):
            payout_token = UNSET
        else:
            payout_token = self.payout_token

        profile_id: Union[None, Unset, str]
        if isinstance(self.profile_id, Unset):
            profile_id = UNSET
        else:
            profile_id = self.profile_id

        priority: Union[None, Unset, str]
        if isinstance(self.priority, Unset):
            priority = UNSET
        elif isinstance(self.priority, PayoutSendPriority):
            priority = self.priority.value
        else:
            priority = self.priority

        payout_link: Union[None, Unset, bool]
        if isinstance(self.payout_link, Unset):
            payout_link = UNSET
        else:
            payout_link = self.payout_link

        payout_link_config: Union[None, Unset, dict[str, Any]]
        if isinstance(self.payout_link_config, Unset):
            payout_link_config = UNSET
        elif isinstance(self.payout_link_config, PayoutCreatePayoutLinkConfig):
            payout_link_config = self.payout_link_config.to_dict()
        else:
            payout_link_config = self.payout_link_config

        session_expiry: Union[None, Unset, int]
        if isinstance(self.session_expiry, Unset):
            session_expiry = UNSET
        else:
            session_expiry = self.session_expiry

        email: Union[None, Unset, str]
        if isinstance(self.email, Unset):
            email = UNSET
        else:
            email = self.email

        name: Union[None, Unset, str]
        if isinstance(self.name, Unset):
            name = UNSET
        else:
            name = self.name

        phone: Union[None, Unset, str]
        if isinstance(self.phone, Unset):
            phone = UNSET
        else:
            phone = self.phone

        phone_country_code: Union[None, Unset, str]
        if isinstance(self.phone_country_code, Unset):
            phone_country_code = UNSET
        else:
            phone_country_code = self.phone_country_code

        payout_method_id: Union[None, Unset, str]
        if isinstance(self.payout_method_id, Unset):
            payout_method_id = UNSET
        else:
            payout_method_id = self.payout_method_id

        field_dict: dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update(
            {
                "client_secret": client_secret,
            }
        )
        if amount is not UNSET:
            field_dict["amount"] = amount
        if currency is not UNSET:
            field_dict["currency"] = currency
        if routing is not UNSET:
            field_dict["routing"] = routing
        if connector is not UNSET:
            field_dict["connector"] = connector
        if payout_type is not UNSET:
            field_dict["payout_type"] = payout_type
        if payout_method_data is not UNSET:
            field_dict["payout_method_data"] = payout_method_data
        if billing is not UNSET:
            field_dict["billing"] = billing
        if auto_fulfill is not UNSET:
            field_dict["auto_fulfill"] = auto_fulfill
        if customer_id is not UNSET:
            field_dict["customer_id"] = customer_id
        if customer is not UNSET:
            field_dict["customer"] = customer
        if return_url is not UNSET:
            field_dict["return_url"] = return_url
        if business_country is not UNSET:
            field_dict["business_country"] = business_country
        if business_label is not UNSET:
            field_dict["business_label"] = business_label
        if description is not UNSET:
            field_dict["description"] = description
        if entity_type is not UNSET:
            field_dict["entity_type"] = entity_type
        if recurring is not UNSET:
            field_dict["recurring"] = recurring
        if metadata is not UNSET:
            field_dict["metadata"] = metadata
        if payout_token is not UNSET:
            field_dict["payout_token"] = payout_token
        if profile_id is not UNSET:
            field_dict["profile_id"] = profile_id
        if priority is not UNSET:
            field_dict["priority"] = priority
        if payout_link is not UNSET:
            field_dict["payout_link"] = payout_link
        if payout_link_config is not UNSET:
            field_dict["payout_link_config"] = payout_link_config
        if session_expiry is not UNSET:
            field_dict["session_expiry"] = session_expiry
        if email is not UNSET:
            field_dict["email"] = email
        if name is not UNSET:
            field_dict["name"] = name
        if phone is not UNSET:
            field_dict["phone"] = phone
        if phone_country_code is not UNSET:
            field_dict["phone_country_code"] = phone_country_code
        if payout_method_id is not UNSET:
            field_dict["payout_method_id"] = payout_method_id

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        from ..models.address import Address
        from ..models.customer_details import CustomerDetails
        from ..models.payout_confirm_request_metadata_type_0 import PayoutConfirmRequestMetadataType0
        from ..models.payout_create_payout_link_config import PayoutCreatePayoutLinkConfig
        from ..models.payout_method_data_type_0 import PayoutMethodDataType0
        from ..models.payout_method_data_type_1 import PayoutMethodDataType1
        from ..models.payout_method_data_type_2 import PayoutMethodDataType2
        from ..models.routing_algorithm_type_0 import RoutingAlgorithmType0
        from ..models.routing_algorithm_type_1 import RoutingAlgorithmType1
        from ..models.routing_algorithm_type_2 import RoutingAlgorithmType2
        from ..models.routing_algorithm_type_3 import RoutingAlgorithmType3

        d = dict(src_dict)
        client_secret = d.pop("client_secret")

        def _parse_amount(data: object) -> Union[None, Unset, int]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, int], data)

        amount = _parse_amount(d.pop("amount", UNSET))

        def _parse_currency(data: object) -> Union[Currency, None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, str):
                    raise TypeError()
                currency_type_1 = Currency(data)

                return currency_type_1
            except:  # noqa: E722
                pass
            return cast(Union[Currency, None, Unset], data)

        currency = _parse_currency(d.pop("currency", UNSET))

        def _parse_routing(
            data: object,
        ) -> Union[
            "RoutingAlgorithmType0",
            "RoutingAlgorithmType1",
            "RoutingAlgorithmType2",
            "RoutingAlgorithmType3",
            None,
            Unset,
        ]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_routing_algorithm_type_0 = RoutingAlgorithmType0.from_dict(data)

                return componentsschemas_routing_algorithm_type_0
            except:  # noqa: E722
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_routing_algorithm_type_1 = RoutingAlgorithmType1.from_dict(data)

                return componentsschemas_routing_algorithm_type_1
            except:  # noqa: E722
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_routing_algorithm_type_2 = RoutingAlgorithmType2.from_dict(data)

                return componentsschemas_routing_algorithm_type_2
            except:  # noqa: E722
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_routing_algorithm_type_3 = RoutingAlgorithmType3.from_dict(data)

                return componentsschemas_routing_algorithm_type_3
            except:  # noqa: E722
                pass
            return cast(
                Union[
                    "RoutingAlgorithmType0",
                    "RoutingAlgorithmType1",
                    "RoutingAlgorithmType2",
                    "RoutingAlgorithmType3",
                    None,
                    Unset,
                ],
                data,
            )

        routing = _parse_routing(d.pop("routing", UNSET))

        def _parse_connector(data: object) -> Union[None, Unset, list[PayoutConnectors]]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, list):
                    raise TypeError()
                connector_type_0 = []
                _connector_type_0 = data
                for connector_type_0_item_data in _connector_type_0:
                    connector_type_0_item = PayoutConnectors(connector_type_0_item_data)

                    connector_type_0.append(connector_type_0_item)

                return connector_type_0
            except:  # noqa: E722
                pass
            return cast(Union[None, Unset, list[PayoutConnectors]], data)

        connector = _parse_connector(d.pop("connector", UNSET))

        def _parse_payout_type(data: object) -> Union[None, PayoutType, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, str):
                    raise TypeError()
                payout_type_type_1 = PayoutType(data)

                return payout_type_type_1
            except:  # noqa: E722
                pass
            return cast(Union[None, PayoutType, Unset], data)

        payout_type = _parse_payout_type(d.pop("payout_type", UNSET))

        def _parse_payout_method_data(
            data: object,
        ) -> Union["PayoutMethodDataType0", "PayoutMethodDataType1", "PayoutMethodDataType2", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_payout_method_data_type_0 = PayoutMethodDataType0.from_dict(data)

                return componentsschemas_payout_method_data_type_0
            except:  # noqa: E722
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_payout_method_data_type_1 = PayoutMethodDataType1.from_dict(data)

                return componentsschemas_payout_method_data_type_1
            except:  # noqa: E722
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_payout_method_data_type_2 = PayoutMethodDataType2.from_dict(data)

                return componentsschemas_payout_method_data_type_2
            except:  # noqa: E722
                pass
            return cast(
                Union["PayoutMethodDataType0", "PayoutMethodDataType1", "PayoutMethodDataType2", None, Unset], data
            )

        payout_method_data = _parse_payout_method_data(d.pop("payout_method_data", UNSET))

        def _parse_billing(data: object) -> Union["Address", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                billing_type_1 = Address.from_dict(data)

                return billing_type_1
            except:  # noqa: E722
                pass
            return cast(Union["Address", None, Unset], data)

        billing = _parse_billing(d.pop("billing", UNSET))

        def _parse_auto_fulfill(data: object) -> Union[None, Unset, bool]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, bool], data)

        auto_fulfill = _parse_auto_fulfill(d.pop("auto_fulfill", UNSET))

        def _parse_customer_id(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        customer_id = _parse_customer_id(d.pop("customer_id", UNSET))

        def _parse_customer(data: object) -> Union["CustomerDetails", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                customer_type_1 = CustomerDetails.from_dict(data)

                return customer_type_1
            except:  # noqa: E722
                pass
            return cast(Union["CustomerDetails", None, Unset], data)

        customer = _parse_customer(d.pop("customer", UNSET))

        def _parse_return_url(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        return_url = _parse_return_url(d.pop("return_url", UNSET))

        def _parse_business_country(data: object) -> Union[CountryAlpha2, None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, str):
                    raise TypeError()
                business_country_type_1 = CountryAlpha2(data)

                return business_country_type_1
            except:  # noqa: E722
                pass
            return cast(Union[CountryAlpha2, None, Unset], data)

        business_country = _parse_business_country(d.pop("business_country", UNSET))

        def _parse_business_label(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        business_label = _parse_business_label(d.pop("business_label", UNSET))

        def _parse_description(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        description = _parse_description(d.pop("description", UNSET))

        def _parse_entity_type(data: object) -> Union[None, PayoutEntityType, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, str):
                    raise TypeError()
                entity_type_type_1 = PayoutEntityType(data)

                return entity_type_type_1
            except:  # noqa: E722
                pass
            return cast(Union[None, PayoutEntityType, Unset], data)

        entity_type = _parse_entity_type(d.pop("entity_type", UNSET))

        def _parse_recurring(data: object) -> Union[None, Unset, bool]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, bool], data)

        recurring = _parse_recurring(d.pop("recurring", UNSET))

        def _parse_metadata(data: object) -> Union["PayoutConfirmRequestMetadataType0", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                metadata_type_0 = PayoutConfirmRequestMetadataType0.from_dict(data)

                return metadata_type_0
            except:  # noqa: E722
                pass
            return cast(Union["PayoutConfirmRequestMetadataType0", None, Unset], data)

        metadata = _parse_metadata(d.pop("metadata", UNSET))

        def _parse_payout_token(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        payout_token = _parse_payout_token(d.pop("payout_token", UNSET))

        def _parse_profile_id(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        profile_id = _parse_profile_id(d.pop("profile_id", UNSET))

        def _parse_priority(data: object) -> Union[None, PayoutSendPriority, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, str):
                    raise TypeError()
                priority_type_1 = PayoutSendPriority(data)

                return priority_type_1
            except:  # noqa: E722
                pass
            return cast(Union[None, PayoutSendPriority, Unset], data)

        priority = _parse_priority(d.pop("priority", UNSET))

        def _parse_payout_link(data: object) -> Union[None, Unset, bool]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, bool], data)

        payout_link = _parse_payout_link(d.pop("payout_link", UNSET))

        def _parse_payout_link_config(data: object) -> Union["PayoutCreatePayoutLinkConfig", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                payout_link_config_type_1 = PayoutCreatePayoutLinkConfig.from_dict(data)

                return payout_link_config_type_1
            except:  # noqa: E722
                pass
            return cast(Union["PayoutCreatePayoutLinkConfig", None, Unset], data)

        payout_link_config = _parse_payout_link_config(d.pop("payout_link_config", UNSET))

        def _parse_session_expiry(data: object) -> Union[None, Unset, int]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, int], data)

        session_expiry = _parse_session_expiry(d.pop("session_expiry", UNSET))

        def _parse_email(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        email = _parse_email(d.pop("email", UNSET))

        def _parse_name(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        name = _parse_name(d.pop("name", UNSET))

        def _parse_phone(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        phone = _parse_phone(d.pop("phone", UNSET))

        def _parse_phone_country_code(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        phone_country_code = _parse_phone_country_code(d.pop("phone_country_code", UNSET))

        def _parse_payout_method_id(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        payout_method_id = _parse_payout_method_id(d.pop("payout_method_id", UNSET))

        payout_confirm_request = cls(
            client_secret=client_secret,
            amount=amount,
            currency=currency,
            routing=routing,
            connector=connector,
            payout_type=payout_type,
            payout_method_data=payout_method_data,
            billing=billing,
            auto_fulfill=auto_fulfill,
            customer_id=customer_id,
            customer=customer,
            return_url=return_url,
            business_country=business_country,
            business_label=business_label,
            description=description,
            entity_type=entity_type,
            recurring=recurring,
            metadata=metadata,
            payout_token=payout_token,
            profile_id=profile_id,
            priority=priority,
            payout_link=payout_link,
            payout_link_config=payout_link_config,
            session_expiry=session_expiry,
            email=email,
            name=name,
            phone=phone,
            phone_country_code=phone_country_code,
            payout_method_id=payout_method_id,
        )

        payout_confirm_request.additional_properties = d
        return payout_confirm_request

    @property
    def additional_keys(self) -> list[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
