# coding: utf-8

"""
    Hyperswitch - API Documentation

     ## Get started  Hyperswitch provides a collection of APIs that enable you to process and manage payments. Our APIs accept and return JSON in the HTTP body, and return standard HTTP response codes.  You can consume the APIs directly using your favorite HTTP/REST library.  We have a testing environment referred to \"sandbox\", which you can setup to test API calls without affecting production data. Currently, our sandbox environment is live while our production environment is under development and will be available soon. You can sign up on our Dashboard to get API keys to access Hyperswitch API.  ### Environment  Use the following base URLs when making requests to the APIs:  | Environment   |  Base URL                          | |---------------|------------------------------------| | Sandbox       | <https://sandbox.hyperswitch.io>   | | Production    | <https://api.hyperswitch.io>       |  ## Authentication  When you sign up on our [dashboard](https://app.hyperswitch.io) and create a merchant account, you are given a secret key (also referred as api-key) and a publishable key. You may authenticate all API requests with Hyperswitch server by providing the appropriate key in the request Authorization header.  | Key             |  Description                                                                                  | |-----------------|-----------------------------------------------------------------------------------------------| | api-key         | Private key. Used to authenticate all API requests from your merchant server                  | | publishable key | Unique identifier for your account. Used to authenticate API requests from your app's client  |  Never share your secret api keys. Keep them guarded and secure. 

    The version of the OpenAPI document: 0.1.0
    Contact: hyperswitch@juspay.in
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List
from typing_extensions import Annotated
from hyperswitch.models.currency import Currency
from hyperswitch.models.customer_default_payment_method_response import CustomerDefaultPaymentMethodResponse
from hyperswitch.models.customer_payment_methods_list_response import CustomerPaymentMethodsListResponse
from hyperswitch.models.payment_method_create import PaymentMethodCreate
from hyperswitch.models.payment_method_delete_response import PaymentMethodDeleteResponse
from hyperswitch.models.payment_method_list_response import PaymentMethodListResponse
from hyperswitch.models.payment_method_response import PaymentMethodResponse
from hyperswitch.models.payment_method_update import PaymentMethodUpdate

from hyperswitch.api_client import ApiClient, RequestSerialized
from hyperswitch.api_response import ApiResponse
from hyperswitch.rest import RESTResponseType


class PaymentMethodsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_a_payment_method(
        self,
        payment_method_create: PaymentMethodCreate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaymentMethodResponse:
        """PaymentMethods - Create

        Creates and stores a payment method against a customer. In case of cards, this API should be used only by PCI compliant merchants.

        :param payment_method_create: (required)
        :type payment_method_create: PaymentMethodCreate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_a_payment_method_serialize(
            payment_method_create=payment_method_create,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_a_payment_method_with_http_info(
        self,
        payment_method_create: PaymentMethodCreate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaymentMethodResponse]:
        """PaymentMethods - Create

        Creates and stores a payment method against a customer. In case of cards, this API should be used only by PCI compliant merchants.

        :param payment_method_create: (required)
        :type payment_method_create: PaymentMethodCreate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_a_payment_method_serialize(
            payment_method_create=payment_method_create,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_a_payment_method_without_preload_content(
        self,
        payment_method_create: PaymentMethodCreate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """PaymentMethods - Create

        Creates and stores a payment method against a customer. In case of cards, this API should be used only by PCI compliant merchants.

        :param payment_method_create: (required)
        :type payment_method_create: PaymentMethodCreate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_a_payment_method_serialize(
            payment_method_create=payment_method_create,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '400': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_a_payment_method_serialize(
        self,
        payment_method_create,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if payment_method_create is not None:
            _body_params = payment_method_create


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payment_methods',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_a_payment_method(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaymentMethodDeleteResponse:
        """Payment Method - Delete

        Deletes a payment method of a customer.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_a_payment_method_serialize(
            method_id=method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodDeleteResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_a_payment_method_with_http_info(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaymentMethodDeleteResponse]:
        """Payment Method - Delete

        Deletes a payment method of a customer.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_a_payment_method_serialize(
            method_id=method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodDeleteResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_a_payment_method_without_preload_content(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Payment Method - Delete

        Deletes a payment method of a customer.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_a_payment_method_serialize(
            method_id=method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodDeleteResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_a_payment_method_serialize(
        self,
        method_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if method_id is not None:
            _path_params['method_id'] = method_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/payment_methods/{method_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_all_payment_methods_for_a_customer(
        self,
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the customer account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerPaymentMethodsListResponse:
        """List payment methods for a Customer

        Lists all the applicable payment methods for a particular Customer ID.

        :param customer_id: The unique identifier for the customer account (required)
        :type customer_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_customer_serialize(
            customer_id=customer_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerPaymentMethodsListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_all_payment_methods_for_a_customer_with_http_info(
        self,
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the customer account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerPaymentMethodsListResponse]:
        """List payment methods for a Customer

        Lists all the applicable payment methods for a particular Customer ID.

        :param customer_id: The unique identifier for the customer account (required)
        :type customer_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_customer_serialize(
            customer_id=customer_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerPaymentMethodsListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_all_payment_methods_for_a_customer_without_preload_content(
        self,
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the customer account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List payment methods for a Customer

        Lists all the applicable payment methods for a particular Customer ID.

        :param customer_id: The unique identifier for the customer account (required)
        :type customer_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_customer_serialize(
            customer_id=customer_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerPaymentMethodsListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_all_payment_methods_for_a_customer_serialize(
        self,
        customer_id,
        accepted_country,
        accepted_currency,
        minimum_amount,
        maximum_amount,
        recurring_payment_enabled,
        installment_payment_enabled,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'accepted_country': 'multi',
            'accepted_currency': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if customer_id is not None:
            _path_params['customer_id'] = customer_id
        if accepted_currency is not None:
            _path_params['accepted_currency'] = accepted_currency
        # process the query parameters
        if accepted_country is not None:
            
            _query_params.append(('accepted_country', accepted_country))
            
        if minimum_amount is not None:
            
            _query_params.append(('minimum_amount', minimum_amount))
            
        if maximum_amount is not None:
            
            _query_params.append(('maximum_amount', maximum_amount))
            
        if recurring_payment_enabled is not None:
            
            _query_params.append(('recurring_payment_enabled', recurring_payment_enabled))
            
        if installment_payment_enabled is not None:
            
            _query_params.append(('installment_payment_enabled', installment_payment_enabled))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/customers/{customer_id}/payment_methods',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_all_payment_methods_for_a_customer_0(
        self,
        client_secret: Annotated[StrictStr, Field(description="A secret known only to your client and the authorization server. Used for client side authentication")],
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the customer account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerPaymentMethodsListResponse:
        """List customer saved payment methods for a Payment

        Lists all the applicable payment methods for a particular payment tied to the `client_secret`.

        :param client_secret: A secret known only to your client and the authorization server. Used for client side authentication (required)
        :type client_secret: str
        :param customer_id: The unique identifier for the customer account (required)
        :type customer_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_customer_0_serialize(
            client_secret=client_secret,
            customer_id=customer_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerPaymentMethodsListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_all_payment_methods_for_a_customer_0_with_http_info(
        self,
        client_secret: Annotated[StrictStr, Field(description="A secret known only to your client and the authorization server. Used for client side authentication")],
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the customer account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerPaymentMethodsListResponse]:
        """List customer saved payment methods for a Payment

        Lists all the applicable payment methods for a particular payment tied to the `client_secret`.

        :param client_secret: A secret known only to your client and the authorization server. Used for client side authentication (required)
        :type client_secret: str
        :param customer_id: The unique identifier for the customer account (required)
        :type customer_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_customer_0_serialize(
            client_secret=client_secret,
            customer_id=customer_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerPaymentMethodsListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_all_payment_methods_for_a_customer_0_without_preload_content(
        self,
        client_secret: Annotated[StrictStr, Field(description="A secret known only to your client and the authorization server. Used for client side authentication")],
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the customer account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List customer saved payment methods for a Payment

        Lists all the applicable payment methods for a particular payment tied to the `client_secret`.

        :param client_secret: A secret known only to your client and the authorization server. Used for client side authentication (required)
        :type client_secret: str
        :param customer_id: The unique identifier for the customer account (required)
        :type customer_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_customer_0_serialize(
            client_secret=client_secret,
            customer_id=customer_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerPaymentMethodsListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_all_payment_methods_for_a_customer_0_serialize(
        self,
        client_secret,
        customer_id,
        accepted_country,
        accepted_currency,
        minimum_amount,
        maximum_amount,
        recurring_payment_enabled,
        installment_payment_enabled,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'accepted_country': 'multi',
            'accepted_currency': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if client_secret is not None:
            _path_params['client-secret'] = client_secret
        if customer_id is not None:
            _path_params['customer_id'] = customer_id
        if accepted_currency is not None:
            _path_params['accepted_currency'] = accepted_currency
        # process the query parameters
        if accepted_country is not None:
            
            _query_params.append(('accepted_country', accepted_country))
            
        if minimum_amount is not None:
            
            _query_params.append(('minimum_amount', minimum_amount))
            
        if maximum_amount is not None:
            
            _query_params.append(('maximum_amount', maximum_amount))
            
        if recurring_payment_enabled is not None:
            
            _query_params.append(('recurring_payment_enabled', recurring_payment_enabled))
            
        if installment_payment_enabled is not None:
            
            _query_params.append(('installment_payment_enabled', installment_payment_enabled))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'publishable_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/customers/payment_methods',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_all_payment_methods_for_a_merchant(
        self,
        account_id: Annotated[StrictStr, Field(description="The unique identifier for the merchant account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaymentMethodListResponse:
        """List payment methods for a Merchant

        Lists the applicable payment methods for a particular Merchant ID. Use the client secret and publishable key authorization to list all relevant payment methods of the merchant for the payment corresponding to the client secret.

        :param account_id: The unique identifier for the merchant account (required)
        :type account_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_merchant_serialize(
            account_id=account_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_all_payment_methods_for_a_merchant_with_http_info(
        self,
        account_id: Annotated[StrictStr, Field(description="The unique identifier for the merchant account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaymentMethodListResponse]:
        """List payment methods for a Merchant

        Lists the applicable payment methods for a particular Merchant ID. Use the client secret and publishable key authorization to list all relevant payment methods of the merchant for the payment corresponding to the client secret.

        :param account_id: The unique identifier for the merchant account (required)
        :type account_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_merchant_serialize(
            account_id=account_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_all_payment_methods_for_a_merchant_without_preload_content(
        self,
        account_id: Annotated[StrictStr, Field(description="The unique identifier for the merchant account")],
        accepted_country: Annotated[List[StrictStr], Field(description="The two-letter ISO currency code")],
        accepted_currency: Annotated[List[Currency], Field(description="The three-letter ISO currency code")],
        minimum_amount: Annotated[StrictInt, Field(description="The minimum amount accepted for processing by the particular payment method.")],
        maximum_amount: Annotated[StrictInt, Field(description="The maximum amount accepted for processing by the particular payment method.")],
        recurring_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for recurring payments")],
        installment_payment_enabled: Annotated[StrictBool, Field(description="Indicates whether the payment method is eligible for installment payments")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List payment methods for a Merchant

        Lists the applicable payment methods for a particular Merchant ID. Use the client secret and publishable key authorization to list all relevant payment methods of the merchant for the payment corresponding to the client secret.

        :param account_id: The unique identifier for the merchant account (required)
        :type account_id: str
        :param accepted_country: The two-letter ISO currency code (required)
        :type accepted_country: List[str]
        :param accepted_currency: The three-letter ISO currency code (required)
        :type accepted_currency: List[Currency]
        :param minimum_amount: The minimum amount accepted for processing by the particular payment method. (required)
        :type minimum_amount: int
        :param maximum_amount: The maximum amount accepted for processing by the particular payment method. (required)
        :type maximum_amount: int
        :param recurring_payment_enabled: Indicates whether the payment method is eligible for recurring payments (required)
        :type recurring_payment_enabled: bool
        :param installment_payment_enabled: Indicates whether the payment method is eligible for installment payments (required)
        :type installment_payment_enabled: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_all_payment_methods_for_a_merchant_serialize(
            account_id=account_id,
            accepted_country=accepted_country,
            accepted_currency=accepted_currency,
            minimum_amount=minimum_amount,
            maximum_amount=maximum_amount,
            recurring_payment_enabled=recurring_payment_enabled,
            installment_payment_enabled=installment_payment_enabled,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodListResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_all_payment_methods_for_a_merchant_serialize(
        self,
        account_id,
        accepted_country,
        accepted_currency,
        minimum_amount,
        maximum_amount,
        recurring_payment_enabled,
        installment_payment_enabled,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'accepted_country': 'multi',
            'accepted_currency': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if account_id is not None:
            _path_params['account_id'] = account_id
        if accepted_currency is not None:
            _path_params['accepted_currency'] = accepted_currency
        # process the query parameters
        if accepted_country is not None:
            
            _query_params.append(('accepted_country', accepted_country))
            
        if minimum_amount is not None:
            
            _query_params.append(('minimum_amount', minimum_amount))
            
        if maximum_amount is not None:
            
            _query_params.append(('maximum_amount', maximum_amount))
            
        if recurring_payment_enabled is not None:
            
            _query_params.append(('recurring_payment_enabled', recurring_payment_enabled))
            
        if installment_payment_enabled is not None:
            
            _query_params.append(('installment_payment_enabled', installment_payment_enabled))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'publishable_key', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/account/payment_methods',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def retrieve_a_payment_method(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaymentMethodResponse:
        """Payment Method - Retrieve

        Retrieves a payment method of a customer.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_a_payment_method_serialize(
            method_id=method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def retrieve_a_payment_method_with_http_info(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaymentMethodResponse]:
        """Payment Method - Retrieve

        Retrieves a payment method of a customer.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_a_payment_method_serialize(
            method_id=method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def retrieve_a_payment_method_without_preload_content(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Payment Method - Retrieve

        Retrieves a payment method of a customer.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retrieve_a_payment_method_serialize(
            method_id=method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _retrieve_a_payment_method_serialize(
        self,
        method_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if method_id is not None:
            _path_params['method_id'] = method_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/payment_methods/{method_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def set_the_payment_method_as_default(
        self,
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the Customer")],
        payment_method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerDefaultPaymentMethodResponse:
        """Payment Method - Set Default Payment Method for Customer

        Set the Payment Method as Default for the Customer.

        :param customer_id: The unique identifier for the Customer (required)
        :type customer_id: str
        :param payment_method_id: The unique identifier for the Payment Method (required)
        :type payment_method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_the_payment_method_as_default_serialize(
            customer_id=customer_id,
            payment_method_id=payment_method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerDefaultPaymentMethodResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_the_payment_method_as_default_with_http_info(
        self,
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the Customer")],
        payment_method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerDefaultPaymentMethodResponse]:
        """Payment Method - Set Default Payment Method for Customer

        Set the Payment Method as Default for the Customer.

        :param customer_id: The unique identifier for the Customer (required)
        :type customer_id: str
        :param payment_method_id: The unique identifier for the Payment Method (required)
        :type payment_method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_the_payment_method_as_default_serialize(
            customer_id=customer_id,
            payment_method_id=payment_method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerDefaultPaymentMethodResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def set_the_payment_method_as_default_without_preload_content(
        self,
        customer_id: Annotated[StrictStr, Field(description="The unique identifier for the Customer")],
        payment_method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Payment Method - Set Default Payment Method for Customer

        Set the Payment Method as Default for the Customer.

        :param customer_id: The unique identifier for the Customer (required)
        :type customer_id: str
        :param payment_method_id: The unique identifier for the Payment Method (required)
        :type payment_method_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_the_payment_method_as_default_serialize(
            customer_id=customer_id,
            payment_method_id=payment_method_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerDefaultPaymentMethodResponse",
            '400': None,
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _set_the_payment_method_as_default_serialize(
        self,
        customer_id,
        payment_method_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if customer_id is not None:
            _path_params['customer_id'] = customer_id
        if payment_method_id is not None:
            _path_params['payment_method_id'] = payment_method_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ephemeral_key'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/{customer_id}/payment_methods/{payment_method_id}/default',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_a_payment_method(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        payment_method_update: PaymentMethodUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PaymentMethodResponse:
        """Payment Method - Update

        Update an existing payment method of a customer. This API is useful for use cases such as updating the card number for expired cards to prevent discontinuity in recurring payments.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param payment_method_update: (required)
        :type payment_method_update: PaymentMethodUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_a_payment_method_serialize(
            method_id=method_id,
            payment_method_update=payment_method_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_a_payment_method_with_http_info(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        payment_method_update: PaymentMethodUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PaymentMethodResponse]:
        """Payment Method - Update

        Update an existing payment method of a customer. This API is useful for use cases such as updating the card number for expired cards to prevent discontinuity in recurring payments.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param payment_method_update: (required)
        :type payment_method_update: PaymentMethodUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_a_payment_method_serialize(
            method_id=method_id,
            payment_method_update=payment_method_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_a_payment_method_without_preload_content(
        self,
        method_id: Annotated[StrictStr, Field(description="The unique identifier for the Payment Method")],
        payment_method_update: PaymentMethodUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Payment Method - Update

        Update an existing payment method of a customer. This API is useful for use cases such as updating the card number for expired cards to prevent discontinuity in recurring payments.

        :param method_id: The unique identifier for the Payment Method (required)
        :type method_id: str
        :param payment_method_update: (required)
        :type payment_method_update: PaymentMethodUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_a_payment_method_serialize(
            method_id=method_id,
            payment_method_update=payment_method_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PaymentMethodResponse",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_a_payment_method_serialize(
        self,
        method_id,
        payment_method_update,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if method_id is not None:
            _path_params['method_id'] = method_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if payment_method_update is not None:
            _body_params = payment_method_update


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'publishable_key', 
            'api_key'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/payment_methods/{method_id}/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


