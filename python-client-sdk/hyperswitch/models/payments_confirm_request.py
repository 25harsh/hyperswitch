# coding: utf-8

"""
    Hyperswitch - API Documentation

     ## Get started  Hyperswitch provides a collection of APIs that enable you to process and manage payments. Our APIs accept and return JSON in the HTTP body, and return standard HTTP response codes.  You can consume the APIs directly using your favorite HTTP/REST library.  We have a testing environment referred to \"sandbox\", which you can setup to test API calls without affecting production data. Currently, our sandbox environment is live while our production environment is under development and will be available soon. You can sign up on our Dashboard to get API keys to access Hyperswitch API.  ### Environment  Use the following base URLs when making requests to the APIs:  | Environment   |  Base URL                          | |---------------|------------------------------------| | Sandbox       | <https://sandbox.hyperswitch.io>   | | Production    | <https://api.hyperswitch.io>       |  ## Authentication  When you sign up on our [dashboard](https://app.hyperswitch.io) and create a merchant account, you are given a secret key (also referred as api-key) and a publishable key. You may authenticate all API requests with Hyperswitch server by providing the appropriate key in the request Authorization header.  | Key             |  Description                                                                                  | |-----------------|-----------------------------------------------------------------------------------------------| | api-key         | Private key. Used to authenticate all API requests from your merchant server                  | | publishable key | Unique identifier for your account. Used to authenticate API requests from your app's client  |  Never share your secret api keys. Keep them guarded and secure. 

    The version of the OpenAPI document: 0.1.0
    Contact: hyperswitch@juspay.in
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from hyperswitch.models.address import Address
from hyperswitch.models.authentication_type import AuthenticationType
from hyperswitch.models.browser_information import BrowserInformation
from hyperswitch.models.capture_method import CaptureMethod
from hyperswitch.models.connector import Connector
from hyperswitch.models.connector_metadata import ConnectorMetadata
from hyperswitch.models.ctp_service_details import CtpServiceDetails
from hyperswitch.models.currency import Currency
from hyperswitch.models.customer_acceptance import CustomerAcceptance
from hyperswitch.models.customer_details import CustomerDetails
from hyperswitch.models.future_usage import FutureUsage
from hyperswitch.models.mandate_data import MandateData
from hyperswitch.models.merchant_connector_details_wrap import MerchantConnectorDetailsWrap
from hyperswitch.models.order_details_with_amount import OrderDetailsWithAmount
from hyperswitch.models.payment_create_payment_link_config import PaymentCreatePaymentLinkConfig
from hyperswitch.models.payment_experience import PaymentExperience
from hyperswitch.models.payment_method import PaymentMethod
from hyperswitch.models.payment_method_data_request import PaymentMethodDataRequest
from hyperswitch.models.payment_method_type import PaymentMethodType
from hyperswitch.models.payment_type import PaymentType
from hyperswitch.models.recurring_details import RecurringDetails
from hyperswitch.models.retry_action import RetryAction
from hyperswitch.models.sca_exemption_type import ScaExemptionType
from hyperswitch.models.split_payments_request import SplitPaymentsRequest
from hyperswitch.models.straight_through_algorithm import StraightThroughAlgorithm
from hyperswitch.models.three_ds_completion_indicator import ThreeDsCompletionIndicator
from typing import Optional, Set
from typing_extensions import Self

class PaymentsConfirmRequest(BaseModel):
    """
    PaymentsConfirmRequest
    """ # noqa: E501
    amount: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="The payment amount. Amount for the payment in the lowest denomination of the currency, (i.e) in cents for USD denomination, in yen for JPY denomination etc. E.g., Pass 100 to charge $1.00 and 1 for 1¥ since ¥ is a zero-decimal currency. Read more about [the Decimal and Non-Decimal Currencies](https://github.com/juspay/hyperswitch/wiki/Decimal-and-Non%E2%80%90Decimal-Currencies)")
    order_tax_amount: Optional[StrictInt] = Field(default=None, description="Total tax amount applicable to the order")
    currency: Optional[Currency] = None
    amount_to_capture: Optional[StrictInt] = Field(default=None, description="The Amount to be captured / debited from the users payment method. It shall be in lowest denomination of the currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc., If not provided, the default amount_to_capture will be the payment amount. Also, it must be less than or equal to the original payment account.")
    shipping_cost: Optional[StrictInt] = Field(default=None, description="The shipping cost for the payment. This is required for tax calculation in some regions.")
    payment_id: Optional[Annotated[str, Field(min_length=30, strict=True, max_length=30)]] = Field(default=None, description="Unique identifier for the payment. This ensures idempotency for multiple payments that have been done by a single merchant. The value for this field can be specified in the request, it will be auto generated otherwise and returned in the API response.")
    routing: Optional[StraightThroughAlgorithm] = None
    connector: Optional[List[Connector]] = Field(default=None, description="This allows to manually select a connector with which the payment can go through.")
    capture_method: Optional[CaptureMethod] = None
    authentication_type: Optional[AuthenticationType] = None
    billing: Optional[Address] = None
    confirm: Optional[StrictBool] = Field(default=False, description="Whether to confirm the payment (if applicable). It can be used to completely process a payment by attaching a payment method, setting `confirm=true` and `capture_method = automatic` in the *Payments/Create API* request itself.")
    customer: Optional[CustomerDetails] = None
    customer_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]] = Field(default=None, description="The identifier for the customer")
    off_session: Optional[StrictBool] = Field(default=None, description="Set to true to indicate that the customer is not in your checkout flow during this payment, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and charge them later. When making a recurring payment by passing a mandate_id, this parameter is mandatory")
    description: Optional[StrictStr] = Field(default=None, description="A description for the payment")
    return_url: Optional[StrictStr] = Field(default=None, description="The URL to which you want the user to be redirected after the completion of the payment operation")
    setup_future_usage: Optional[FutureUsage] = None
    payment_method_data: Optional[PaymentMethodDataRequest] = None
    payment_method: Optional[PaymentMethod] = None
    payment_token: Optional[StrictStr] = Field(default=None, description="As Hyperswitch tokenises the sensitive details about the payments method, it provides the payment_token as a reference to a stored payment method, ensuring that the sensitive details are not exposed in any manner.")
    shipping: Optional[Address] = None
    statement_descriptor_name: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.")
    statement_descriptor_suffix: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.")
    order_details: Optional[List[OrderDetailsWithAmount]] = Field(default=None, description="Use this object to capture the details about the different products for which the payment is being made. The sum of amount across different products here should be equal to the overall payment amount")
    client_secret: Optional[StrictStr] = Field(default=None, description="It's a token used for client side verification.")
    mandate_data: Optional[MandateData] = None
    customer_acceptance: Optional[CustomerAcceptance] = None
    mandate_id: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="A unique identifier to link the payment to a mandate. To do Recurring payments after a mandate has been created, pass the mandate_id instead of payment_method_data")
    browser_info: Optional[BrowserInformation] = None
    payment_experience: Optional[PaymentExperience] = None
    payment_method_type: Optional[PaymentMethodType] = None
    merchant_connector_details: Optional[MerchantConnectorDetailsWrap] = None
    allowed_payment_method_types: Optional[List[PaymentMethodType]] = Field(default=None, description="Use this parameter to restrict the Payment Method Types to show for a given PaymentIntent")
    retry_action: Optional[RetryAction] = None
    metadata: Optional[Dict[str, Any]] = Field(default=None, description="You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.")
    connector_metadata: Optional[ConnectorMetadata] = None
    payment_link: Optional[StrictBool] = Field(default=False, description="Whether to generate the payment link for this payment or not (if applicable)")
    payment_link_config: Optional[PaymentCreatePaymentLinkConfig] = None
    payment_link_config_id: Optional[StrictStr] = Field(default=None, description="Custom payment link config id set at business profile, send only if business_specific_configs is configured")
    payment_type: Optional[PaymentType] = None
    request_incremental_authorization: Optional[StrictBool] = Field(default=None, description="Request an incremental authorization, i.e., increase the authorized amount on a confirmed payment before you capture it.")
    session_expiry: Optional[Annotated[int, Field(strict=True, ge=0)]] = Field(default=None, description="Will be used to expire client secret after certain amount of time to be supplied in seconds (900) for 15 mins")
    frm_metadata: Optional[Dict[str, Any]] = Field(default=None, description="Additional data related to some frm(Fraud Risk Management) connectors")
    request_external_three_ds_authentication: Optional[StrictBool] = Field(default=None, description="Whether to perform external authentication (if applicable)")
    recurring_details: Optional[RecurringDetails] = None
    split_payments: Optional[SplitPaymentsRequest] = None
    request_extended_authorization: Optional[StrictBool] = Field(default=False, description="Optional boolean value to extent authorization period of this payment  capture method must be manual or manual_multiple")
    merchant_order_reference_id: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="Merchant's identifier for the payment/invoice. This will be sent to the connector if the connector provides support to accept multiple reference ids. In case the connector supports only one reference id, Hyperswitch's Payment ID will be sent as reference.")
    skip_external_tax_calculation: Optional[StrictBool] = Field(default=None, description="Whether to calculate tax for this payment intent")
    psd2_sca_exemption_type: Optional[ScaExemptionType] = None
    ctp_service_details: Optional[CtpServiceDetails] = None
    force_3ds_challenge: Optional[StrictBool] = Field(default=None, description="Indicates if 3ds challenge is forced")
    threeds_method_comp_ind: Optional[ThreeDsCompletionIndicator] = None
    __properties: ClassVar[List[str]] = ["amount", "order_tax_amount", "currency", "amount_to_capture", "shipping_cost", "payment_id", "routing", "connector", "capture_method", "authentication_type", "billing", "confirm", "customer", "customer_id", "off_session", "description", "return_url", "setup_future_usage", "payment_method_data", "payment_method", "payment_token", "shipping", "statement_descriptor_name", "statement_descriptor_suffix", "order_details", "client_secret", "mandate_data", "customer_acceptance", "mandate_id", "browser_info", "payment_experience", "payment_method_type", "merchant_connector_details", "allowed_payment_method_types", "retry_action", "metadata", "connector_metadata", "payment_link", "payment_link_config", "payment_link_config_id", "payment_type", "request_incremental_authorization", "session_expiry", "frm_metadata", "request_external_three_ds_authentication", "recurring_details", "split_payments", "request_extended_authorization", "merchant_order_reference_id", "skip_external_tax_calculation", "psd2_sca_exemption_type", "ctp_service_details", "force_3ds_challenge", "threeds_method_comp_ind"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PaymentsConfirmRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of routing
        if self.routing:
            _dict['routing'] = self.routing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of billing
        if self.billing:
            _dict['billing'] = self.billing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of customer
        if self.customer:
            _dict['customer'] = self.customer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payment_method_data
        if self.payment_method_data:
            _dict['payment_method_data'] = self.payment_method_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipping
        if self.shipping:
            _dict['shipping'] = self.shipping.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in order_details (list)
        _items = []
        if self.order_details:
            for _item_order_details in self.order_details:
                if _item_order_details:
                    _items.append(_item_order_details.to_dict())
            _dict['order_details'] = _items
        # override the default output from pydantic by calling `to_dict()` of mandate_data
        if self.mandate_data:
            _dict['mandate_data'] = self.mandate_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of customer_acceptance
        if self.customer_acceptance:
            _dict['customer_acceptance'] = self.customer_acceptance.to_dict()
        # override the default output from pydantic by calling `to_dict()` of browser_info
        if self.browser_info:
            _dict['browser_info'] = self.browser_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of merchant_connector_details
        if self.merchant_connector_details:
            _dict['merchant_connector_details'] = self.merchant_connector_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of connector_metadata
        if self.connector_metadata:
            _dict['connector_metadata'] = self.connector_metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payment_link_config
        if self.payment_link_config:
            _dict['payment_link_config'] = self.payment_link_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of recurring_details
        if self.recurring_details:
            _dict['recurring_details'] = self.recurring_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of split_payments
        if self.split_payments:
            _dict['split_payments'] = self.split_payments.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ctp_service_details
        if self.ctp_service_details:
            _dict['ctp_service_details'] = self.ctp_service_details.to_dict()
        # set to None if amount (nullable) is None
        # and model_fields_set contains the field
        if self.amount is None and "amount" in self.model_fields_set:
            _dict['amount'] = None

        # set to None if order_tax_amount (nullable) is None
        # and model_fields_set contains the field
        if self.order_tax_amount is None and "order_tax_amount" in self.model_fields_set:
            _dict['order_tax_amount'] = None

        # set to None if currency (nullable) is None
        # and model_fields_set contains the field
        if self.currency is None and "currency" in self.model_fields_set:
            _dict['currency'] = None

        # set to None if amount_to_capture (nullable) is None
        # and model_fields_set contains the field
        if self.amount_to_capture is None and "amount_to_capture" in self.model_fields_set:
            _dict['amount_to_capture'] = None

        # set to None if shipping_cost (nullable) is None
        # and model_fields_set contains the field
        if self.shipping_cost is None and "shipping_cost" in self.model_fields_set:
            _dict['shipping_cost'] = None

        # set to None if payment_id (nullable) is None
        # and model_fields_set contains the field
        if self.payment_id is None and "payment_id" in self.model_fields_set:
            _dict['payment_id'] = None

        # set to None if routing (nullable) is None
        # and model_fields_set contains the field
        if self.routing is None and "routing" in self.model_fields_set:
            _dict['routing'] = None

        # set to None if connector (nullable) is None
        # and model_fields_set contains the field
        if self.connector is None and "connector" in self.model_fields_set:
            _dict['connector'] = None

        # set to None if capture_method (nullable) is None
        # and model_fields_set contains the field
        if self.capture_method is None and "capture_method" in self.model_fields_set:
            _dict['capture_method'] = None

        # set to None if authentication_type (nullable) is None
        # and model_fields_set contains the field
        if self.authentication_type is None and "authentication_type" in self.model_fields_set:
            _dict['authentication_type'] = None

        # set to None if billing (nullable) is None
        # and model_fields_set contains the field
        if self.billing is None and "billing" in self.model_fields_set:
            _dict['billing'] = None

        # set to None if confirm (nullable) is None
        # and model_fields_set contains the field
        if self.confirm is None and "confirm" in self.model_fields_set:
            _dict['confirm'] = None

        # set to None if customer (nullable) is None
        # and model_fields_set contains the field
        if self.customer is None and "customer" in self.model_fields_set:
            _dict['customer'] = None

        # set to None if customer_id (nullable) is None
        # and model_fields_set contains the field
        if self.customer_id is None and "customer_id" in self.model_fields_set:
            _dict['customer_id'] = None

        # set to None if off_session (nullable) is None
        # and model_fields_set contains the field
        if self.off_session is None and "off_session" in self.model_fields_set:
            _dict['off_session'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if return_url (nullable) is None
        # and model_fields_set contains the field
        if self.return_url is None and "return_url" in self.model_fields_set:
            _dict['return_url'] = None

        # set to None if setup_future_usage (nullable) is None
        # and model_fields_set contains the field
        if self.setup_future_usage is None and "setup_future_usage" in self.model_fields_set:
            _dict['setup_future_usage'] = None

        # set to None if payment_method_data (nullable) is None
        # and model_fields_set contains the field
        if self.payment_method_data is None and "payment_method_data" in self.model_fields_set:
            _dict['payment_method_data'] = None

        # set to None if payment_method (nullable) is None
        # and model_fields_set contains the field
        if self.payment_method is None and "payment_method" in self.model_fields_set:
            _dict['payment_method'] = None

        # set to None if payment_token (nullable) is None
        # and model_fields_set contains the field
        if self.payment_token is None and "payment_token" in self.model_fields_set:
            _dict['payment_token'] = None

        # set to None if shipping (nullable) is None
        # and model_fields_set contains the field
        if self.shipping is None and "shipping" in self.model_fields_set:
            _dict['shipping'] = None

        # set to None if statement_descriptor_name (nullable) is None
        # and model_fields_set contains the field
        if self.statement_descriptor_name is None and "statement_descriptor_name" in self.model_fields_set:
            _dict['statement_descriptor_name'] = None

        # set to None if statement_descriptor_suffix (nullable) is None
        # and model_fields_set contains the field
        if self.statement_descriptor_suffix is None and "statement_descriptor_suffix" in self.model_fields_set:
            _dict['statement_descriptor_suffix'] = None

        # set to None if order_details (nullable) is None
        # and model_fields_set contains the field
        if self.order_details is None and "order_details" in self.model_fields_set:
            _dict['order_details'] = None

        # set to None if client_secret (nullable) is None
        # and model_fields_set contains the field
        if self.client_secret is None and "client_secret" in self.model_fields_set:
            _dict['client_secret'] = None

        # set to None if mandate_data (nullable) is None
        # and model_fields_set contains the field
        if self.mandate_data is None and "mandate_data" in self.model_fields_set:
            _dict['mandate_data'] = None

        # set to None if customer_acceptance (nullable) is None
        # and model_fields_set contains the field
        if self.customer_acceptance is None and "customer_acceptance" in self.model_fields_set:
            _dict['customer_acceptance'] = None

        # set to None if mandate_id (nullable) is None
        # and model_fields_set contains the field
        if self.mandate_id is None and "mandate_id" in self.model_fields_set:
            _dict['mandate_id'] = None

        # set to None if browser_info (nullable) is None
        # and model_fields_set contains the field
        if self.browser_info is None and "browser_info" in self.model_fields_set:
            _dict['browser_info'] = None

        # set to None if payment_experience (nullable) is None
        # and model_fields_set contains the field
        if self.payment_experience is None and "payment_experience" in self.model_fields_set:
            _dict['payment_experience'] = None

        # set to None if payment_method_type (nullable) is None
        # and model_fields_set contains the field
        if self.payment_method_type is None and "payment_method_type" in self.model_fields_set:
            _dict['payment_method_type'] = None

        # set to None if merchant_connector_details (nullable) is None
        # and model_fields_set contains the field
        if self.merchant_connector_details is None and "merchant_connector_details" in self.model_fields_set:
            _dict['merchant_connector_details'] = None

        # set to None if allowed_payment_method_types (nullable) is None
        # and model_fields_set contains the field
        if self.allowed_payment_method_types is None and "allowed_payment_method_types" in self.model_fields_set:
            _dict['allowed_payment_method_types'] = None

        # set to None if retry_action (nullable) is None
        # and model_fields_set contains the field
        if self.retry_action is None and "retry_action" in self.model_fields_set:
            _dict['retry_action'] = None

        # set to None if metadata (nullable) is None
        # and model_fields_set contains the field
        if self.metadata is None and "metadata" in self.model_fields_set:
            _dict['metadata'] = None

        # set to None if connector_metadata (nullable) is None
        # and model_fields_set contains the field
        if self.connector_metadata is None and "connector_metadata" in self.model_fields_set:
            _dict['connector_metadata'] = None

        # set to None if payment_link (nullable) is None
        # and model_fields_set contains the field
        if self.payment_link is None and "payment_link" in self.model_fields_set:
            _dict['payment_link'] = None

        # set to None if payment_link_config (nullable) is None
        # and model_fields_set contains the field
        if self.payment_link_config is None and "payment_link_config" in self.model_fields_set:
            _dict['payment_link_config'] = None

        # set to None if payment_link_config_id (nullable) is None
        # and model_fields_set contains the field
        if self.payment_link_config_id is None and "payment_link_config_id" in self.model_fields_set:
            _dict['payment_link_config_id'] = None

        # set to None if payment_type (nullable) is None
        # and model_fields_set contains the field
        if self.payment_type is None and "payment_type" in self.model_fields_set:
            _dict['payment_type'] = None

        # set to None if request_incremental_authorization (nullable) is None
        # and model_fields_set contains the field
        if self.request_incremental_authorization is None and "request_incremental_authorization" in self.model_fields_set:
            _dict['request_incremental_authorization'] = None

        # set to None if session_expiry (nullable) is None
        # and model_fields_set contains the field
        if self.session_expiry is None and "session_expiry" in self.model_fields_set:
            _dict['session_expiry'] = None

        # set to None if frm_metadata (nullable) is None
        # and model_fields_set contains the field
        if self.frm_metadata is None and "frm_metadata" in self.model_fields_set:
            _dict['frm_metadata'] = None

        # set to None if request_external_three_ds_authentication (nullable) is None
        # and model_fields_set contains the field
        if self.request_external_three_ds_authentication is None and "request_external_three_ds_authentication" in self.model_fields_set:
            _dict['request_external_three_ds_authentication'] = None

        # set to None if recurring_details (nullable) is None
        # and model_fields_set contains the field
        if self.recurring_details is None and "recurring_details" in self.model_fields_set:
            _dict['recurring_details'] = None

        # set to None if split_payments (nullable) is None
        # and model_fields_set contains the field
        if self.split_payments is None and "split_payments" in self.model_fields_set:
            _dict['split_payments'] = None

        # set to None if request_extended_authorization (nullable) is None
        # and model_fields_set contains the field
        if self.request_extended_authorization is None and "request_extended_authorization" in self.model_fields_set:
            _dict['request_extended_authorization'] = None

        # set to None if merchant_order_reference_id (nullable) is None
        # and model_fields_set contains the field
        if self.merchant_order_reference_id is None and "merchant_order_reference_id" in self.model_fields_set:
            _dict['merchant_order_reference_id'] = None

        # set to None if skip_external_tax_calculation (nullable) is None
        # and model_fields_set contains the field
        if self.skip_external_tax_calculation is None and "skip_external_tax_calculation" in self.model_fields_set:
            _dict['skip_external_tax_calculation'] = None

        # set to None if psd2_sca_exemption_type (nullable) is None
        # and model_fields_set contains the field
        if self.psd2_sca_exemption_type is None and "psd2_sca_exemption_type" in self.model_fields_set:
            _dict['psd2_sca_exemption_type'] = None

        # set to None if ctp_service_details (nullable) is None
        # and model_fields_set contains the field
        if self.ctp_service_details is None and "ctp_service_details" in self.model_fields_set:
            _dict['ctp_service_details'] = None

        # set to None if force_3ds_challenge (nullable) is None
        # and model_fields_set contains the field
        if self.force_3ds_challenge is None and "force_3ds_challenge" in self.model_fields_set:
            _dict['force_3ds_challenge'] = None

        # set to None if threeds_method_comp_ind (nullable) is None
        # and model_fields_set contains the field
        if self.threeds_method_comp_ind is None and "threeds_method_comp_ind" in self.model_fields_set:
            _dict['threeds_method_comp_ind'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PaymentsConfirmRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "amount": obj.get("amount"),
            "order_tax_amount": obj.get("order_tax_amount"),
            "currency": obj.get("currency"),
            "amount_to_capture": obj.get("amount_to_capture"),
            "shipping_cost": obj.get("shipping_cost"),
            "payment_id": obj.get("payment_id"),
            "routing": StraightThroughAlgorithm.from_dict(obj["routing"]) if obj.get("routing") is not None else None,
            "connector": obj.get("connector"),
            "capture_method": obj.get("capture_method"),
            "authentication_type": obj.get("authentication_type"),
            "billing": Address.from_dict(obj["billing"]) if obj.get("billing") is not None else None,
            "confirm": obj.get("confirm") if obj.get("confirm") is not None else False,
            "customer": CustomerDetails.from_dict(obj["customer"]) if obj.get("customer") is not None else None,
            "customer_id": obj.get("customer_id"),
            "off_session": obj.get("off_session"),
            "description": obj.get("description"),
            "return_url": obj.get("return_url"),
            "setup_future_usage": obj.get("setup_future_usage"),
            "payment_method_data": PaymentMethodDataRequest.from_dict(obj["payment_method_data"]) if obj.get("payment_method_data") is not None else None,
            "payment_method": obj.get("payment_method"),
            "payment_token": obj.get("payment_token"),
            "shipping": Address.from_dict(obj["shipping"]) if obj.get("shipping") is not None else None,
            "statement_descriptor_name": obj.get("statement_descriptor_name"),
            "statement_descriptor_suffix": obj.get("statement_descriptor_suffix"),
            "order_details": [OrderDetailsWithAmount.from_dict(_item) for _item in obj["order_details"]] if obj.get("order_details") is not None else None,
            "client_secret": obj.get("client_secret"),
            "mandate_data": MandateData.from_dict(obj["mandate_data"]) if obj.get("mandate_data") is not None else None,
            "customer_acceptance": CustomerAcceptance.from_dict(obj["customer_acceptance"]) if obj.get("customer_acceptance") is not None else None,
            "mandate_id": obj.get("mandate_id"),
            "browser_info": BrowserInformation.from_dict(obj["browser_info"]) if obj.get("browser_info") is not None else None,
            "payment_experience": obj.get("payment_experience"),
            "payment_method_type": obj.get("payment_method_type"),
            "merchant_connector_details": MerchantConnectorDetailsWrap.from_dict(obj["merchant_connector_details"]) if obj.get("merchant_connector_details") is not None else None,
            "allowed_payment_method_types": obj.get("allowed_payment_method_types"),
            "retry_action": obj.get("retry_action"),
            "metadata": obj.get("metadata"),
            "connector_metadata": ConnectorMetadata.from_dict(obj["connector_metadata"]) if obj.get("connector_metadata") is not None else None,
            "payment_link": obj.get("payment_link") if obj.get("payment_link") is not None else False,
            "payment_link_config": PaymentCreatePaymentLinkConfig.from_dict(obj["payment_link_config"]) if obj.get("payment_link_config") is not None else None,
            "payment_link_config_id": obj.get("payment_link_config_id"),
            "payment_type": obj.get("payment_type"),
            "request_incremental_authorization": obj.get("request_incremental_authorization"),
            "session_expiry": obj.get("session_expiry"),
            "frm_metadata": obj.get("frm_metadata"),
            "request_external_three_ds_authentication": obj.get("request_external_three_ds_authentication"),
            "recurring_details": RecurringDetails.from_dict(obj["recurring_details"]) if obj.get("recurring_details") is not None else None,
            "split_payments": SplitPaymentsRequest.from_dict(obj["split_payments"]) if obj.get("split_payments") is not None else None,
            "request_extended_authorization": obj.get("request_extended_authorization") if obj.get("request_extended_authorization") is not None else False,
            "merchant_order_reference_id": obj.get("merchant_order_reference_id"),
            "skip_external_tax_calculation": obj.get("skip_external_tax_calculation"),
            "psd2_sca_exemption_type": obj.get("psd2_sca_exemption_type"),
            "ctp_service_details": CtpServiceDetails.from_dict(obj["ctp_service_details"]) if obj.get("ctp_service_details") is not None else None,
            "force_3ds_challenge": obj.get("force_3ds_challenge"),
            "threeds_method_comp_ind": obj.get("threeds_method_comp_ind")
        })
        return _obj


