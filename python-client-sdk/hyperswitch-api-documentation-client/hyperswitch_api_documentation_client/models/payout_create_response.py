import datetime
from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, TypeVar, Union, cast

from attrs import define as _attrs_define
from dateutil.parser import isoparse

from ..models.country_alpha_2 import CountryAlpha2
from ..models.currency import Currency
from ..models.payout_entity_type import PayoutEntityType
from ..models.payout_send_priority import PayoutSendPriority
from ..models.payout_status import PayoutStatus
from ..models.payout_type import PayoutType
from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.address import Address
    from ..models.customer_details_response import CustomerDetailsResponse
    from ..models.payout_attempt_response import PayoutAttemptResponse
    from ..models.payout_create_response_metadata_type_0 import PayoutCreateResponseMetadataType0
    from ..models.payout_link_response import PayoutLinkResponse
    from ..models.payout_method_data_response_type_0 import PayoutMethodDataResponseType0
    from ..models.payout_method_data_response_type_1 import PayoutMethodDataResponseType1
    from ..models.payout_method_data_response_type_2 import PayoutMethodDataResponseType2


T = TypeVar("T", bound="PayoutCreateResponse")


@_attrs_define
class PayoutCreateResponse:
    """
    Attributes:
        payout_id (str): Unique identifier for the payout. This ensures idempotency for multiple payouts
            that have been done by a single merchant. This field is auto generated and is returned in the API response.
            Example: 187282ab-40ef-47a9-9206-5099ba31e432.
        merchant_id (str): This is an identifier for the merchant account. This is inferred from the API key
            provided during the request Example: merchant_1668273825.
        amount (int): The payout amount. Amount for the payout in lowest denomination of the currency. (i.e) in cents
            for USD denomination, in paisa for INR denomination etc., Example: 1000.
        currency (Currency): The three letter ISO currency code in uppercase. Eg: 'USD' for the United States Dollar.
        auto_fulfill (bool): Set to true to confirm the payout without review, no further action required Default:
            False. Example: True.
        customer_id (str): The identifier for the customer object. If not provided the customer ID will be
            autogenerated. Example: cus_y3oqhf46pyzuxjbcn2giaqnb44.
        client_secret (str): It's a token used for client side verification. Example:
            pay_U42c409qyHwOkWo3vK60_secret_el9ksDkiB8hi6j9N78yo.
        return_url (str): The URL to redirect after the completion of the operation Example: https://hyperswitch.io.
        business_country (CountryAlpha2):
        entity_type (PayoutEntityType): Type of entity to whom the payout is being carried out to, select from the given
            list of options
        recurring (bool): Specifies whether or not the payout request is recurring Default: False.
        status (PayoutStatus):
        profile_id (str): The business profile that is associated with this payout
        connector (Union[None, Unset, str]): The connector used for the payout Example: wise.
        payout_type (Union[None, PayoutType, Unset]):
        payout_method_data (Union['PayoutMethodDataResponseType0', 'PayoutMethodDataResponseType1',
            'PayoutMethodDataResponseType2', None, Unset]):
        billing (Union['Address', None, Unset]):
        customer (Union['CustomerDetailsResponse', None, Unset]):
        business_label (Union[None, Unset, str]): Business label of the merchant for this payout Example: food.
        description (Union[None, Unset, str]): A description of the payout Example: It's my first payout request.
        metadata (Union['PayoutCreateResponseMetadataType0', None, Unset]): You can specify up to 50 keys, with key
            names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional,
            structured information on an object.
        merchant_connector_id (Union[None, Unset, str]): Unique identifier of the merchant connector account Example:
            mca_sAD3OZLATetvjLOYhUSy.
        error_message (Union[None, Unset, str]): If there was an error while calling the connector the error message is
            received here Example: Failed while verifying the card.
        error_code (Union[None, Unset, str]): If there was an error while calling the connectors the code is received
            here Example: E0001.
        created (Union[None, Unset, datetime.datetime]): Time when the payout was created Example: 2022-09-10T10:11:12Z.
        connector_transaction_id (Union[None, Unset, str]): Underlying processor's payout resource ID Example:
            S3FC9G9M2MVFDXT5.
        priority (Union[None, PayoutSendPriority, Unset]):
        attempts (Union[None, Unset, list['PayoutAttemptResponse']]): List of attempts
        payout_link (Union['PayoutLinkResponse', None, Unset]):
        email (Union[None, Unset, str]): Customer's email. _Deprecated: Use customer object instead._ Example:
            johntest@test.com.
        name (Union[None, Unset, str]): Customer's name. _Deprecated: Use customer object instead._ Example: John Test.
        phone (Union[None, Unset, str]): Customer's phone. _Deprecated: Use customer object instead._ Example:
            9123456789.
        phone_country_code (Union[None, Unset, str]): Customer's phone country code. _Deprecated: Use customer object
            instead._ Example: +1.
        unified_code (Union[None, Unset, str]): (This field is not live yet)
            Error code unified across the connectors is received here in case of errors while calling the underlying
            connector Example: UE_000.
        unified_message (Union[None, Unset, str]): (This field is not live yet)
            Error message unified across the connectors is received here in case of errors while calling the underlying
            connector Example: Invalid card details.
        payout_method_id (Union[None, Unset, str]): Identifier for payout method
    """

    payout_id: str
    merchant_id: str
    amount: int
    currency: Currency
    customer_id: str
    client_secret: str
    return_url: str
    business_country: CountryAlpha2
    entity_type: PayoutEntityType
    status: PayoutStatus
    profile_id: str
    auto_fulfill: bool = False
    recurring: bool = False
    connector: Union[None, Unset, str] = UNSET
    payout_type: Union[None, PayoutType, Unset] = UNSET
    payout_method_data: Union[
        "PayoutMethodDataResponseType0", "PayoutMethodDataResponseType1", "PayoutMethodDataResponseType2", None, Unset
    ] = UNSET
    billing: Union["Address", None, Unset] = UNSET
    customer: Union["CustomerDetailsResponse", None, Unset] = UNSET
    business_label: Union[None, Unset, str] = UNSET
    description: Union[None, Unset, str] = UNSET
    metadata: Union["PayoutCreateResponseMetadataType0", None, Unset] = UNSET
    merchant_connector_id: Union[None, Unset, str] = UNSET
    error_message: Union[None, Unset, str] = UNSET
    error_code: Union[None, Unset, str] = UNSET
    created: Union[None, Unset, datetime.datetime] = UNSET
    connector_transaction_id: Union[None, Unset, str] = UNSET
    priority: Union[None, PayoutSendPriority, Unset] = UNSET
    attempts: Union[None, Unset, list["PayoutAttemptResponse"]] = UNSET
    payout_link: Union["PayoutLinkResponse", None, Unset] = UNSET
    email: Union[None, Unset, str] = UNSET
    name: Union[None, Unset, str] = UNSET
    phone: Union[None, Unset, str] = UNSET
    phone_country_code: Union[None, Unset, str] = UNSET
    unified_code: Union[None, Unset, str] = UNSET
    unified_message: Union[None, Unset, str] = UNSET
    payout_method_id: Union[None, Unset, str] = UNSET

    def to_dict(self) -> dict[str, Any]:
        from ..models.address import Address
        from ..models.customer_details_response import CustomerDetailsResponse
        from ..models.payout_create_response_metadata_type_0 import PayoutCreateResponseMetadataType0
        from ..models.payout_link_response import PayoutLinkResponse
        from ..models.payout_method_data_response_type_0 import PayoutMethodDataResponseType0
        from ..models.payout_method_data_response_type_1 import PayoutMethodDataResponseType1
        from ..models.payout_method_data_response_type_2 import PayoutMethodDataResponseType2

        payout_id = self.payout_id

        merchant_id = self.merchant_id

        amount = self.amount

        currency = self.currency.value

        auto_fulfill = self.auto_fulfill

        customer_id = self.customer_id

        client_secret = self.client_secret

        return_url = self.return_url

        business_country = self.business_country.value

        entity_type = self.entity_type.value

        recurring = self.recurring

        status = self.status.value

        profile_id = self.profile_id

        connector: Union[None, Unset, str]
        if isinstance(self.connector, Unset):
            connector = UNSET
        else:
            connector = self.connector

        payout_type: Union[None, Unset, str]
        if isinstance(self.payout_type, Unset):
            payout_type = UNSET
        elif isinstance(self.payout_type, PayoutType):
            payout_type = self.payout_type.value
        else:
            payout_type = self.payout_type

        payout_method_data: Union[None, Unset, dict[str, Any]]
        if isinstance(self.payout_method_data, Unset):
            payout_method_data = UNSET
        elif isinstance(self.payout_method_data, PayoutMethodDataResponseType0):
            payout_method_data = self.payout_method_data.to_dict()
        elif isinstance(self.payout_method_data, PayoutMethodDataResponseType1):
            payout_method_data = self.payout_method_data.to_dict()
        elif isinstance(self.payout_method_data, PayoutMethodDataResponseType2):
            payout_method_data = self.payout_method_data.to_dict()
        else:
            payout_method_data = self.payout_method_data

        billing: Union[None, Unset, dict[str, Any]]
        if isinstance(self.billing, Unset):
            billing = UNSET
        elif isinstance(self.billing, Address):
            billing = self.billing.to_dict()
        else:
            billing = self.billing

        customer: Union[None, Unset, dict[str, Any]]
        if isinstance(self.customer, Unset):
            customer = UNSET
        elif isinstance(self.customer, CustomerDetailsResponse):
            customer = self.customer.to_dict()
        else:
            customer = self.customer

        business_label: Union[None, Unset, str]
        if isinstance(self.business_label, Unset):
            business_label = UNSET
        else:
            business_label = self.business_label

        description: Union[None, Unset, str]
        if isinstance(self.description, Unset):
            description = UNSET
        else:
            description = self.description

        metadata: Union[None, Unset, dict[str, Any]]
        if isinstance(self.metadata, Unset):
            metadata = UNSET
        elif isinstance(self.metadata, PayoutCreateResponseMetadataType0):
            metadata = self.metadata.to_dict()
        else:
            metadata = self.metadata

        merchant_connector_id: Union[None, Unset, str]
        if isinstance(self.merchant_connector_id, Unset):
            merchant_connector_id = UNSET
        else:
            merchant_connector_id = self.merchant_connector_id

        error_message: Union[None, Unset, str]
        if isinstance(self.error_message, Unset):
            error_message = UNSET
        else:
            error_message = self.error_message

        error_code: Union[None, Unset, str]
        if isinstance(self.error_code, Unset):
            error_code = UNSET
        else:
            error_code = self.error_code

        created: Union[None, Unset, str]
        if isinstance(self.created, Unset):
            created = UNSET
        elif isinstance(self.created, datetime.datetime):
            created = self.created.isoformat()
        else:
            created = self.created

        connector_transaction_id: Union[None, Unset, str]
        if isinstance(self.connector_transaction_id, Unset):
            connector_transaction_id = UNSET
        else:
            connector_transaction_id = self.connector_transaction_id

        priority: Union[None, Unset, str]
        if isinstance(self.priority, Unset):
            priority = UNSET
        elif isinstance(self.priority, PayoutSendPriority):
            priority = self.priority.value
        else:
            priority = self.priority

        attempts: Union[None, Unset, list[dict[str, Any]]]
        if isinstance(self.attempts, Unset):
            attempts = UNSET
        elif isinstance(self.attempts, list):
            attempts = []
            for attempts_type_0_item_data in self.attempts:
                attempts_type_0_item = attempts_type_0_item_data.to_dict()
                attempts.append(attempts_type_0_item)

        else:
            attempts = self.attempts

        payout_link: Union[None, Unset, dict[str, Any]]
        if isinstance(self.payout_link, Unset):
            payout_link = UNSET
        elif isinstance(self.payout_link, PayoutLinkResponse):
            payout_link = self.payout_link.to_dict()
        else:
            payout_link = self.payout_link

        email: Union[None, Unset, str]
        if isinstance(self.email, Unset):
            email = UNSET
        else:
            email = self.email

        name: Union[None, Unset, str]
        if isinstance(self.name, Unset):
            name = UNSET
        else:
            name = self.name

        phone: Union[None, Unset, str]
        if isinstance(self.phone, Unset):
            phone = UNSET
        else:
            phone = self.phone

        phone_country_code: Union[None, Unset, str]
        if isinstance(self.phone_country_code, Unset):
            phone_country_code = UNSET
        else:
            phone_country_code = self.phone_country_code

        unified_code: Union[None, Unset, str]
        if isinstance(self.unified_code, Unset):
            unified_code = UNSET
        else:
            unified_code = self.unified_code

        unified_message: Union[None, Unset, str]
        if isinstance(self.unified_message, Unset):
            unified_message = UNSET
        else:
            unified_message = self.unified_message

        payout_method_id: Union[None, Unset, str]
        if isinstance(self.payout_method_id, Unset):
            payout_method_id = UNSET
        else:
            payout_method_id = self.payout_method_id

        field_dict: dict[str, Any] = {}
        field_dict.update(
            {
                "payout_id": payout_id,
                "merchant_id": merchant_id,
                "amount": amount,
                "currency": currency,
                "auto_fulfill": auto_fulfill,
                "customer_id": customer_id,
                "client_secret": client_secret,
                "return_url": return_url,
                "business_country": business_country,
                "entity_type": entity_type,
                "recurring": recurring,
                "status": status,
                "profile_id": profile_id,
            }
        )
        if connector is not UNSET:
            field_dict["connector"] = connector
        if payout_type is not UNSET:
            field_dict["payout_type"] = payout_type
        if payout_method_data is not UNSET:
            field_dict["payout_method_data"] = payout_method_data
        if billing is not UNSET:
            field_dict["billing"] = billing
        if customer is not UNSET:
            field_dict["customer"] = customer
        if business_label is not UNSET:
            field_dict["business_label"] = business_label
        if description is not UNSET:
            field_dict["description"] = description
        if metadata is not UNSET:
            field_dict["metadata"] = metadata
        if merchant_connector_id is not UNSET:
            field_dict["merchant_connector_id"] = merchant_connector_id
        if error_message is not UNSET:
            field_dict["error_message"] = error_message
        if error_code is not UNSET:
            field_dict["error_code"] = error_code
        if created is not UNSET:
            field_dict["created"] = created
        if connector_transaction_id is not UNSET:
            field_dict["connector_transaction_id"] = connector_transaction_id
        if priority is not UNSET:
            field_dict["priority"] = priority
        if attempts is not UNSET:
            field_dict["attempts"] = attempts
        if payout_link is not UNSET:
            field_dict["payout_link"] = payout_link
        if email is not UNSET:
            field_dict["email"] = email
        if name is not UNSET:
            field_dict["name"] = name
        if phone is not UNSET:
            field_dict["phone"] = phone
        if phone_country_code is not UNSET:
            field_dict["phone_country_code"] = phone_country_code
        if unified_code is not UNSET:
            field_dict["unified_code"] = unified_code
        if unified_message is not UNSET:
            field_dict["unified_message"] = unified_message
        if payout_method_id is not UNSET:
            field_dict["payout_method_id"] = payout_method_id

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        from ..models.address import Address
        from ..models.customer_details_response import CustomerDetailsResponse
        from ..models.payout_attempt_response import PayoutAttemptResponse
        from ..models.payout_create_response_metadata_type_0 import PayoutCreateResponseMetadataType0
        from ..models.payout_link_response import PayoutLinkResponse
        from ..models.payout_method_data_response_type_0 import PayoutMethodDataResponseType0
        from ..models.payout_method_data_response_type_1 import PayoutMethodDataResponseType1
        from ..models.payout_method_data_response_type_2 import PayoutMethodDataResponseType2

        d = dict(src_dict)
        payout_id = d.pop("payout_id")

        merchant_id = d.pop("merchant_id")

        amount = d.pop("amount")

        currency = Currency(d.pop("currency"))

        auto_fulfill = d.pop("auto_fulfill")

        customer_id = d.pop("customer_id")

        client_secret = d.pop("client_secret")

        return_url = d.pop("return_url")

        business_country = CountryAlpha2(d.pop("business_country"))

        entity_type = PayoutEntityType(d.pop("entity_type"))

        recurring = d.pop("recurring")

        status = PayoutStatus(d.pop("status"))

        profile_id = d.pop("profile_id")

        def _parse_connector(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        connector = _parse_connector(d.pop("connector", UNSET))

        def _parse_payout_type(data: object) -> Union[None, PayoutType, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, str):
                    raise TypeError()
                payout_type_type_1 = PayoutType(data)

                return payout_type_type_1
            except:  # noqa: E722
                pass
            return cast(Union[None, PayoutType, Unset], data)

        payout_type = _parse_payout_type(d.pop("payout_type", UNSET))

        def _parse_payout_method_data(
            data: object,
        ) -> Union[
            "PayoutMethodDataResponseType0",
            "PayoutMethodDataResponseType1",
            "PayoutMethodDataResponseType2",
            None,
            Unset,
        ]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_payout_method_data_response_type_0 = PayoutMethodDataResponseType0.from_dict(data)

                return componentsschemas_payout_method_data_response_type_0
            except:  # noqa: E722
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_payout_method_data_response_type_1 = PayoutMethodDataResponseType1.from_dict(data)

                return componentsschemas_payout_method_data_response_type_1
            except:  # noqa: E722
                pass
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                componentsschemas_payout_method_data_response_type_2 = PayoutMethodDataResponseType2.from_dict(data)

                return componentsschemas_payout_method_data_response_type_2
            except:  # noqa: E722
                pass
            return cast(
                Union[
                    "PayoutMethodDataResponseType0",
                    "PayoutMethodDataResponseType1",
                    "PayoutMethodDataResponseType2",
                    None,
                    Unset,
                ],
                data,
            )

        payout_method_data = _parse_payout_method_data(d.pop("payout_method_data", UNSET))

        def _parse_billing(data: object) -> Union["Address", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                billing_type_1 = Address.from_dict(data)

                return billing_type_1
            except:  # noqa: E722
                pass
            return cast(Union["Address", None, Unset], data)

        billing = _parse_billing(d.pop("billing", UNSET))

        def _parse_customer(data: object) -> Union["CustomerDetailsResponse", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                customer_type_1 = CustomerDetailsResponse.from_dict(data)

                return customer_type_1
            except:  # noqa: E722
                pass
            return cast(Union["CustomerDetailsResponse", None, Unset], data)

        customer = _parse_customer(d.pop("customer", UNSET))

        def _parse_business_label(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        business_label = _parse_business_label(d.pop("business_label", UNSET))

        def _parse_description(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        description = _parse_description(d.pop("description", UNSET))

        def _parse_metadata(data: object) -> Union["PayoutCreateResponseMetadataType0", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                metadata_type_0 = PayoutCreateResponseMetadataType0.from_dict(data)

                return metadata_type_0
            except:  # noqa: E722
                pass
            return cast(Union["PayoutCreateResponseMetadataType0", None, Unset], data)

        metadata = _parse_metadata(d.pop("metadata", UNSET))

        def _parse_merchant_connector_id(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        merchant_connector_id = _parse_merchant_connector_id(d.pop("merchant_connector_id", UNSET))

        def _parse_error_message(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        error_message = _parse_error_message(d.pop("error_message", UNSET))

        def _parse_error_code(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        error_code = _parse_error_code(d.pop("error_code", UNSET))

        def _parse_created(data: object) -> Union[None, Unset, datetime.datetime]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, str):
                    raise TypeError()
                created_type_0 = isoparse(data)

                return created_type_0
            except:  # noqa: E722
                pass
            return cast(Union[None, Unset, datetime.datetime], data)

        created = _parse_created(d.pop("created", UNSET))

        def _parse_connector_transaction_id(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        connector_transaction_id = _parse_connector_transaction_id(d.pop("connector_transaction_id", UNSET))

        def _parse_priority(data: object) -> Union[None, PayoutSendPriority, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, str):
                    raise TypeError()
                priority_type_1 = PayoutSendPriority(data)

                return priority_type_1
            except:  # noqa: E722
                pass
            return cast(Union[None, PayoutSendPriority, Unset], data)

        priority = _parse_priority(d.pop("priority", UNSET))

        def _parse_attempts(data: object) -> Union[None, Unset, list["PayoutAttemptResponse"]]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, list):
                    raise TypeError()
                attempts_type_0 = []
                _attempts_type_0 = data
                for attempts_type_0_item_data in _attempts_type_0:
                    attempts_type_0_item = PayoutAttemptResponse.from_dict(attempts_type_0_item_data)

                    attempts_type_0.append(attempts_type_0_item)

                return attempts_type_0
            except:  # noqa: E722
                pass
            return cast(Union[None, Unset, list["PayoutAttemptResponse"]], data)

        attempts = _parse_attempts(d.pop("attempts", UNSET))

        def _parse_payout_link(data: object) -> Union["PayoutLinkResponse", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                payout_link_type_1 = PayoutLinkResponse.from_dict(data)

                return payout_link_type_1
            except:  # noqa: E722
                pass
            return cast(Union["PayoutLinkResponse", None, Unset], data)

        payout_link = _parse_payout_link(d.pop("payout_link", UNSET))

        def _parse_email(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        email = _parse_email(d.pop("email", UNSET))

        def _parse_name(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        name = _parse_name(d.pop("name", UNSET))

        def _parse_phone(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        phone = _parse_phone(d.pop("phone", UNSET))

        def _parse_phone_country_code(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        phone_country_code = _parse_phone_country_code(d.pop("phone_country_code", UNSET))

        def _parse_unified_code(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        unified_code = _parse_unified_code(d.pop("unified_code", UNSET))

        def _parse_unified_message(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        unified_message = _parse_unified_message(d.pop("unified_message", UNSET))

        def _parse_payout_method_id(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        payout_method_id = _parse_payout_method_id(d.pop("payout_method_id", UNSET))

        payout_create_response = cls(
            payout_id=payout_id,
            merchant_id=merchant_id,
            amount=amount,
            currency=currency,
            auto_fulfill=auto_fulfill,
            customer_id=customer_id,
            client_secret=client_secret,
            return_url=return_url,
            business_country=business_country,
            entity_type=entity_type,
            recurring=recurring,
            status=status,
            profile_id=profile_id,
            connector=connector,
            payout_type=payout_type,
            payout_method_data=payout_method_data,
            billing=billing,
            customer=customer,
            business_label=business_label,
            description=description,
            metadata=metadata,
            merchant_connector_id=merchant_connector_id,
            error_message=error_message,
            error_code=error_code,
            created=created,
            connector_transaction_id=connector_transaction_id,
            priority=priority,
            attempts=attempts,
            payout_link=payout_link,
            email=email,
            name=name,
            phone=phone,
            phone_country_code=phone_country_code,
            unified_code=unified_code,
            unified_message=unified_message,
            payout_method_id=payout_method_id,
        )

        return payout_create_response
